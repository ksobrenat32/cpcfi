\documentclass[10pt]{article}
\usepackage[landscape, letterpaper, top=3cm, bottom=1.5cm, left=1.5cm, right=1.5cm]{geometry}
\usepackage{multicol}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{titletoc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{ragged2e}
\usepackage{xltabular}
\usepackage{multirow}
\usepackage{amsmath}

% Configure column separation line
\setlength{\columnsep}{1cm}
\setlength{\columnseprule}{0.4pt}

% Compact C++ listing style
\lstdefinestyle{compactcpp}{
    language=C++,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=3pt,
    backgroundcolor=\color{white},
    frame=single,
    framesep=1pt,
    rulecolor=\color{black!30},
    tabsize=4,
    showstringspaces=false,
    breaklines=true,
    belowskip=0pt,
    aboveskip=4pt
}

% Page style configuration
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\sectionmark}[1]{\markboth{#1}{}} % Remove section numbers from header
\fancyhead[L]{\authorname} % Left header
\fancyhead[C]{\leftmark} % Center header
\fancyhead[R]{Page \thepage\ of \pageref{LastPage}} % Right header
\fancyheadoffset{0pt}

% Author name definition
\newcommand{\authorname}{\textbf{Enrique Calderon, Luis Salazar, Gustavo Valenzuela}}

% Table of Contents formatting
\contentsmargin{0pt}
\dottedcontents{section}[1.5em]{}{2em}{1pc}
\dottedcontents{subsection}[3.8em]{}{2.8em}{1pc}

% Custom title page
\newcommand{\maketitlepage}{
    \begin{titlepage}
        \centering
        \vspace*{2cm}
        {\Huge\bfseries ICPC MX 2025 Reference\par}
        \vspace{1cm}
        {\Large \authorname \par}

        \vspace{2cm}
        {\large Last Updated: \today\par}
        \vfill
    \end{titlepage}
}

\begin{document}

% Title Page
\maketitlepage
\cleardoublepage

% Table of Contents Section
\section*{Table of Contents}
\begin{multicols*}{2}
    \startcontents[sections]
    \printcontents[sections]{l}{0}{\setcounter{tocdepth}{2}}
\end{multicols*}
\newpage

% Main Content
\begin{multicols*}{2}

\section{C++ Functions}
\subsection{Common STL Algorithms}

\subsection*{Sorting Algorithms}
\begin{tabularx}{\linewidth}{|l|l|X|}
    \hline
    \textbf{Function} & \textbf{Parameters} & \textbf{Description} \\
    \hline
    sort & begin, end, [comp] & Standard unstable sort (O(n log n)) \\
    \hline
    stable\_sort & begin, end, [comp] & Stable sort preserves element order \\
    \hline
    is\_sorted & begin, end, [comp] & Checks if range is sorted (returns bool) \\
    \hline
    nth\_element & begin, nth, end, [comp] & Partitions around nth element \\
    \hline
\end{tabularx}

\subsection*{Searching Functions}
\begin{tabularx}{\linewidth}{|l|l|X|}
    \hline
    \textbf{Function} & \textbf{Parameters} & \textbf{Description} \\
    \hline
    lower\_bound & begin, end, val, [comp] & First element $\leq$ value \\
    \hline
    upper\_bound & begin, end, val, [comp] & First element > value \\
    \hline
    binary\_search & begin, end, val, [comp] & Existence check in sorted range \\
    \hline
    find & begin, end, val & Linear search for value \\
    \hline
    find\_if & begin, end, pred & Find first matching predicate \\
    \hline
\end{tabularx}

\subsection*{Sequence Operations}
\begin{tabularx}{\linewidth}{|l|l|X|}
    \hline
    \textbf{Function} & \textbf{Parameters} & \textbf{Description} \\
    \hline
    reverse & begin, end & Reverse elements in-place \\
    \hline
    rotate & begin, mid, end & Rotate elements left \\
    \hline
    next\_permutation & begin, end & Generate next permutation \\
    \hline
    unique & begin, end, [pred] & Remove consecutive duplicates \\
    \hline
    remove & begin, end, val & Remove elements equal to value \\
    \hline
\end{tabularx}

\subsection*{Numerical Functions}
\begin{tabularx}{\linewidth}{|l|l|X|}
    \hline
    \textbf{Function} & \textbf{Parameters} & \textbf{Description} \\
    \hline
    accumulate & begin, end, init, [op] & Sum/accumulate elements \\
    \hline
    partial\_sum & begin, end, dest, [op] & Compute prefix sums \\
    \hline
    \_\_gcd & a, b & Greatest common divisor (C++17) \\
    \hline
    lcm & a, b & Least common multiple (C++17) \\
    \hline
    iota & begin, end, val & Fill with consecutive values \\
    \hline
\end{tabularx}

\subsection*{Memory/Array Operations}
\begin{tabularx}{\linewidth}{|l|l|X|}
    \hline
    \textbf{Function} & \textbf{Parameters} & \textbf{Description} \\
    \hline
    memset & ptr, value, count & Fill memory with byte value \\
    \hline
    fill & begin, end, value & Fill range with value \\
    \hline
    fill\_n & begin, count, value & Fill N elements with value \\
    \hline
    copy & src\_b, src\_e, dest & Copy range to destination \\
    \hline
    copy\_if & src\_b, src\_e, dest, pred & Copy elements matching predicate \\
    \hline
\end{tabularx}

\subsection*{Utility Functions}
\begin{tabularx}{\linewidth}{|l|l|X|}
    \hline
    \textbf{Function} & \textbf{Parameters} & \textbf{Description} \\
    \hline
    swap & a, b & Swap two values \\
    \hline
    max\_element & begin, end, [comp] & Find maximum element \\
    \hline
    min\_element & begin, end, [comp] & Find minimum element \\
    \hline
    count & begin, end, val & Count element occurrences \\
    \hline
    all\_of & begin, end, pred & Check all elements satisfy condition \\
    \hline
\end{tabularx}

\subsection*{Mathematical / Bitwise Builtins}
\begin{tabularx}{\linewidth}{|l|l|X|}
    \hline
    \textbf{Function} & \textbf{Parameters} & \textbf{Description} \\
    \hline
    \_\_builtin\_popcount & x (int) & Count number of 1-bits \\
    \hline
    \_\_builtin\_popcountll & x (long long) & Count number of 1-bits (64-bit) \\
    \hline
    \_\_builtin\_clz & x (unsigned int) & Count leading zeros \\
    \hline
    \_\_builtin\_clzll & x (unsigned long long) & Leading zeros (64-bit) \\
    \hline
    \_\_builtin\_ctz & x (unsigned int) & Count trailing zeros \\
    \hline
    \_\_builtin\_ctzll & x (unsigned long long) & Trailing zeros (64-bit) \\
    \hline
    \_\_builtin\_parity & x & Return 1 if \#bits is odd \\
    \hline
    \_\_builtin\_ffs & x & Position of least significant 1-bit (1-indexed) \\
    \hline
    \_\_lg & x & Floor of $\log_2(x)$ (index of highest bit) \\
    \hline
\end{tabularx}

\subsection*{Priority Queues and Heaps}
\begin{tabularx}{\linewidth}{|l|l|X|}
    \hline
    \textbf{Function} & \textbf{Parameters} & \textbf{Description} \\
    \hline
    priority\_queue & [type], [container], [comp] & Max-heap by default \\
    \hline
    make\_heap & begin, end, [comp] & Turn range into heap \\
    \hline
    push\_heap & begin, end, [comp] & Push element into heap \\
    \hline
    pop\_heap & begin, end, [comp] & Pop max element into end \\
    \hline
    sort\_heap & begin, end, [comp] & Heap sort \\
    \hline
\end{tabularx}

\subsection*{Set / Map Utilities}
\begin{tabularx}{\linewidth}{|l|l|X|}
    \hline
    \textbf{Operation} & \textbf{Usage} & \textbf{Description} \\
    \hline
    s.lower\_bound(x) & set/map & First element $\geq$ x \\
    \hline
    s.upper\_bound(x) & set/map & First element $>$ x \\
    \hline
    s.equal\_range(x) & multiset/map & Pair of lower/upper bound \\
    \hline
    s.erase(it) & iterator & Erase element at iterator \\
    \hline
    s.find(x) & key & Iterator to key or end \\
    \hline
\end{tabularx}

\subsection*{String Functions}
\begin{tabularx}{\linewidth}{|l|l|X|}
    \hline
    \textbf{Function} & \textbf{Parameters} & \textbf{Description} \\
    \hline
    stoi, stol, stoll & string, [pos], [base] & Convert string $\to$ int/long/ll \\
    \hline
    stoul, stoull & string, [pos], [base] & Convert string $\to$ unsigned \\
    \hline
    stod, stof, stold & string & Convert string $\to$ double/float/long double \\
    \hline
    to\_string & value & Convert number $\to$ string \\
    \hline
    substr & pos, len & Substring \\
    \hline
    find & str, pos & Find first occurrence \\
    \hline
    rfind & str, pos & Find last occurrence \\
    \hline
\end{tabularx}

\subsection*{Random Number Utilities}
\begin{tabularx}{\linewidth}{|l|l|X|}
    \hline
    \textbf{Type / Function} & \textbf{Usage} & \textbf{Description} \\
    \hline
    mt19937 rng & chrono::steady\_clock::now() & Fast random generator \\
    \hline
    uniform\_int\_distribution & dist(a,b)(rng) & Random int in [a,b] \\
    \hline
    shuffle & begin, end, rng & Random shuffle \\
    \hline
\end{tabularx}

\subsection*{Other Useful Utilities}
\begin{tabularx}{\linewidth}{|l|l|X|}
    \hline
    \textbf{Function} & \textbf{Parameters} & \textbf{Description} \\
    \hline
    chrono::high\_resolution\_clock & now() & Get precise current time \\
    \hline
    \_\_int128 & value & 128-bit integer (manual I/O needed) \\
    \hline
    bitset<N> & ops: \&, |, \^, <<, >> & Fixed-size bitset manipulation \\
    \hline
    tuple & get$<i>$(t) & Store and access heterogenous data \\
    \hline
    pair & first, second & Store pair of values \\
    \hline
\end{tabularx}

\section{Binary search}

Searching algorithm for sorted arrays or monotonic functions. Time complexity: O(log n).

\subsection*{Standard Binary Search}

\begin{lstlisting}[style=compactcpp]
    // Standard binary search (iterative)
    int binary_search(vector<int>& arr, int target) {
        int left = 0, right = arr.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) return mid;
            if (arr[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return -1;
    }

    // Binary search on real numbers (e.g. sqrt)
    double sqrt_precision(double n, double eps=1e-6) {
        double left = 0, right = n;
        for (int i = 0; i < 100; ++i) { // or while (right-left > eps)
            double mid = (left + right) / 2;
            if (mid*mid < n) left = mid;
            else right = mid;
        }
        return left;
    }
\end{lstlisting}

\subsection*{Lower and Upper Bound}
    
\begin{lstlisting}[style=compactcpp]
    // Lower bound (first element >= target)
    int lower_bound(vector<int>& arr, int target) {
        int left = 0, right = arr.size();
        while (left < right) {
            int mid = left + (right - left) / 2;
            arr[mid] < target ? left = mid + 1 
                              : right = mid;
        }
        return left;
    }
    
    // Upper bound (first element > target)
    int upper_bound(vector<int>& arr, int target) {
        int left = 0, right = arr.size();
        while (left < right) {
            int mid = left + (right - left) / 2;
            arr[mid] <= target ? left = mid + 1 
                               : right = mid;
        }
        return left;
    }    
\end{lstlisting}

\subsection*{Binary Search on Answer Space}

\begin{lstlisting}[style=compactcpp]
    // Binary search on answer space (monotonic condition)
    int find_min_valid(vector<int>& nums, int k) {
        auto is_valid = [&](int x) { 
            /* condition check */ 
        };
        
        int left = 0, right = 1e9; // adjust bounds
        while (left < right) {
            int mid = left + (right - left) / 2;
            is_valid(mid) ? right = mid 
                          : left = mid + 1;
        }
        return left;
    }
\end{lstlisting}

\section{Data Structures}

\subsection{Fenwick Tree}

\begin{lstlisting}[style=compactcpp]
struct FenwickTree {
    vector<int> bit;  // binary indexed tree
    int n;

    FenwickTree(int n) {
        this->n = n;
        bit.assign(n, 0);
    }

    FenwickTree(vector<int> const &a) : FenwickTree(a.size()){
    for (int i = 0; i < n; i++) {
        bit[i] += a[i];
        int r = i | (i + 1);
        if (r < n) bit[r] += bit[i];
    }
}

    FenwickTree(vector<int> const &a) : FenwickTree(a.size()) {
        for (size_t i = 0; i < a.size(); i++)
            add(i, a[i]);
    }

    int sum(int r) {
        int ret = 0;
        for (; r >= 0; r = (r & (r + 1)) - 1)
            ret += bit[r];
        return ret;
    }

    int sum(int l, int r) {
        return sum(r) - sum(l - 1);
    }

    void add(int idx, int delta) {
        for (; idx < n; idx = idx | (idx + 1))
            bit[idx] += delta;
    }
};
\end{lstlisting}

\subsection{Fenwick Minimum}

\begin{lstlisting}[style=compactcpp]
struct FenwickTreeMin {
    vector<int> bit;
    int n;
    const int INF = (int)1e9;

    FenwickTreeMin(int n) {
        this->n = n;
        bit.assign(n, INF);
    }

    FenwickTreeMin(vector<int> a) : FenwickTreeMin(a.size()) {
        for (size_t i = 0; i < a.size(); i++)
            update(i, a[i]);
    }

    int getmin(int r) {
        int ret = INF;
        for (; r >= 0; r = (r & (r + 1)) - 1)
            ret = min(ret, bit[r]);
        return ret;
    }

    void update(int idx, int val) {
        for (; idx < n; idx = idx | (idx + 1))
            bit[idx] = min(bit[idx], val);
    }
};
\end{lstlisting}

\subsection{Fenwick 2D (Sum query)}
\begin{lstlisting}[style=compactcpp]
struct Fenwick2D {
    vector<vector<int>> tree;
    int rows, cols;
    
    Fenwick2D(int r, int c) : rows(r), cols(c), 
        tree(r + 1, vector<int>(c + 1)) {}
    
    // Update: add delta to (x, y) (1-based)
    void update(int x, int y, int delta) {
        for(int i = x; i <= rows; i += lsb(i))
            for(int j = y; j <= cols; j += lsb(j))
                tree[i][j] += delta;
    }
    
    // Query sum from (1,1) to (x,y)
    int query(int x, int y) {
        int sum = 0;
        for(int i = x; i > 0; i -= lsb(i))
            for(int j = y; j > 0; j -= lsb(j))
                sum += tree[i][j];
        return sum;
    }
    
    // Range sum from (x1,y1) to (x2,y2)
    int range_query(int x1, int y1, int x2, int y2) {
        return query(x2, y2) - query(x1-1, y2) 
             - query(x2, y1-1) + query(x1-1, y1-1);
    }
    
    int lsb(int i) { return i & -i; }
};
\end{lstlisting}

\subsection{Fenwick 2D (Counting in range)}
\begin{lstlisting}[style=compactcpp]
struct Fenwick2DPerType {
    int rows, cols;
    unordered_map<int, Fenwick2D> trees;  // Map from type to 2D Fenwick Tree

    Fenwick2DPerType(int r, int c) : rows(r), cols(c) {}

    // Update: add 'delta' objects of type 't' at position (x, y)
    void update(int t, int x, int y, int delta) {
        if (trees.find(t) == trees.end()) {
            trees[t] = Fenwick2D(rows, cols);
        }
        trees[t].update(x, y, delta);
    }

    // Query: count of type 't' in rectangle [x1,y1] to [x2,y2]
    int query(int t, int x1, int y1, int x2, int y2) {
        if (trees.find(t) == trees.end()) return 0;
        return trees[t].range_query(x1, y1, x2, y2);
    }
};
\end{lstlisting}

\subsection{Fenwick 2D (Multiple types)}
\begin{lstlisting}[style=compactcpp]
// Requires the base Fenwick2D implementation from previous answer
struct Fenwick2D {
    vector<vector<int>> tree;
    int rows, cols;
    
    Fenwick2D(int r, int c) : rows(r), cols(c), 
        tree(r + 1, vector<int>(c + 1)) {}
    
    // Update: add delta to (x, y) (1-based)
    void update(int x, int y, int delta) {
        for(int i = x; i <= rows; i += lsb(i))
            for(int j = y; j <= cols; j += lsb(j))
                tree[i][j] += delta;
    }
    
    // Query sum from (1,1) to (x,y)
    int query(int x, int y) {
        int sum = 0;
        for(int i = x; i > 0; i -= lsb(i))
            for(int j = y; j > 0; j -= lsb(j))
                sum += tree[i][j];
        return sum;
    }
    
    // Range sum from (x1,y1) to (x2,y2)
    int range_query(int x1, int y1, int x2, int y2) {
        return query(x2, y2) - query(x1-1, y2) 
             - query(x2, y1-1) + query(x1-1, y1-1);
    }
    
    int lsb(int i) { return i & -i; }
};
\end{lstlisting}

\subsection{Fenwick Tree Range Update - Point Query}
\begin{lstlisting}[style=compactcpp]
// Range Update - Point Query (1-based indexing)
struct FenwickRUQ {
    int n;
    std::vector<int> bit;
    
    FenwickRUQ(int size) : n(size + 1), bit(size + 2) {}
    
    // Add val to range [l, r] (1-based)
    void range_add(int l, int r, int val) {
        add(l, val);
        add(r + 1, -val);
    }
    
    // Get value at position idx (1-based)
    int point_query(int idx) {
        int res = 0;
        for(; idx > 0; idx -= idx & -idx)
            res += bit[idx];
        return res;
    }

private:
    void add(int idx, int val) {
        for(; idx < n; idx += idx & -idx)
            bit[idx] += val;
    }
};
\end{lstlisting}

\subsection{Fenwick Tree - Range update and query}

\begin{lstlisting}[style=compactcpp]
// Range Update - Range Query (1-based indexing)
struct FenwickRURQ {
    int n;
    std::vector<int> B1, B2;
    
    FenwickRURQ(int size) : n(size + 1), B1(size + 2), B2(size + 2) {}
    
    // Add val to range [l, r] (1-based)
    void range_add(int l, int r, int val) {
        add(B1, l, val);
        add(B1, r + 1, -val);
        add(B2, l, val * (l - 1));
        add(B2, r + 1, -val * r);
    }
    
    // Get sum of range [l, r] (1-based)
    int range_sum(int l, int r) {
        return prefix_sum(r) - prefix_sum(l - 1);
    }

private:
    void add(std::vector<int>& b, int idx, int val) {
        for(; idx < n; idx += idx & -idx)
            b[idx] += val;
    }
    
    int sum(const std::vector<int>& b, int idx) {
        int total = 0;
        for(; idx > 0; idx -= idx & -idx)
            total += b[idx];
        return total;
    }
    
    int prefix_sum(int idx) {
        return sum(B1, idx) * idx - sum(B2, idx);
    }
};
\end{lstlisting}

\subsection{Segment Tree (Iterative)}

\begin{lstlisting}[style=compactcpp]
int segtree[2*100000 + 5];

    void build(vector<int> &arr, int n){
        for(int i=0; i<n; i++)
            segtree[n+i] = arr[i];
        
        for(int i=n-1; i>=1; i--)
            segtree[i] = max(segtree[2*i], segtree[2*i+1]);
    }

    void update(int pos, int value, int n){
        pos+=n;
        segtree[pos] = value;

        while(pos>1){
            pos>>=1;
            segtree[pos] = max(segtree[2*pos],segtree[2*pos+1]);
        }
    }

    int query(int l, int r, int n){
        l+=n;
        r+=n;

        int mx = INT_MIN;

        while(l <= r){
            if(l % 2 == 1) mx = max(mx, segtree[l++]);
            if(r % 2 == 0) mx = max(mx, segtree[r--]);  
            l >>= 1;
            r >>= 1;
        }

        return mx;
    }
\end{lstlisting}

\subsection{Segment Tree (Class-based with Find Operations)}

\begin{lstlisting}[style=compactcpp]
// Segment Tree class with find_first, find_kth, update and query operations
class SegmentTree{
private:
    vector<int> segtree;
    int n;
    int d;
 
public:
 
    void build(vector<int> &a){
        n = a.size();
        d=1;
        while(d<n) d<<=1;
        segtree.assign(2*d, 0);
        for(int i=0; i<n; i++)
            segtree[d+i] = 1;
        
        for(int i=d-1; i>=1; i--)
            segtree[i] = segtree[2*i] + segtree[2*i+1];
    }
 
    int find_first(int x){
        if(segtree[1]<x) return -1;
        int i=1;
 
        while(i<d){
            if(segtree[2*i] >= x) i = 2*i;
            else i = 2*i+1;
        }
 
 
        return i-d;
    }
 
    int find_kth(int x){
        //if(segtree[1]<x) return -1;
        int i=1;
 
        while(i<d){
            if(segtree[2*i] >= x) i = 2*i;
            else{
                x -= segtree[2*i];
                i = 2*i+1;
            } 
        }
        return i-d;
    }
 
 
    void update(int pos){
        pos+=d;
        segtree[pos] = 0; 
        
        while(pos>1){ 
            pos>>=1; 
            segtree[pos] = segtree[2*pos] + segtree[2*pos+1];
        }
    }
 
 
    int query(int l, int r){
        l+=d;
        r+=d;
 
        int mx = INT_MIN;
        while(l<=r){
            if(l%2 == 1) mx = max(mx, segtree[l++]);
            if(r%2 == 0) mx = max(mx, segtree[r--]);
            l>>=1;
            r>>=1;
        }
        return mx;
    }
 
};
\end{lstlisting}

\subsection{Merge Sort Tree}

\begin{lstlisting}[style=compactcpp]
// Merge Sort Tree: counts elements less than x in range [l, r] in O(log^2 n)
// Each node stores a sorted array of elements in its range
class MergeSortTree{
private:
    vector<vector<int>> segtree;
    int n;
    int d;
 
public:
    void build(vector<int> &a){
        n = a.size();
        d=1;
        while(d<n) d<<=1;
        segtree.assign(2*d, {0});
        for(int i=0; i<n; i++)
            segtree[d+i] = {a[i]};
        
        for(int i=d-1; i>=1; i--){
            segtree[i].resize(segtree[2*i].size() + segtree[2*i].size());
            merge(segtree[2*i].begin(),segtree[2*i].end(),
                  segtree[2*i+1].begin(), segtree[2*i+1].end(),
                  segtree[i].begin());
        }
            
    }
 
    int query(int l, int r, int x){
        l+=d;
        r+=d;
 
        int arns = 0;
        while(l<=r){
            if(l%2 == 1){
                arns += lower_bound(segtree[l].begin(), segtree[l].end(), x) - segtree[l].begin();
                l++;
            }
            if(r%2 == 0){
                arns += lower_bound(segtree[r].begin(), segtree[r].end(), x) - segtree[r].begin();
                r--;
            }
            l>>=1;
            r>>=1;
        }
        return arns;
    }
 
};
\end{lstlisting}

\subsection{Segment Tree (Sum query)}

\begin{lstlisting}[style=compactcpp]
ll  t[4*MAX];
 
// Shout-out to CP algo for the SegTree implementation: https://cp-algorithms.com/data_structures/segment_tree.html#memory-efficient-implementation
 
void buildSegTree(vector<ll> &a, int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
    } else {
        int tm = (tl + tr) / 2;
        buildSegTree(a, v*2, tl, tm);
        buildSegTree(a, v*2+1, tm+1, tr);
        t[v] = t[v*2] + t[v*2+1];
    }
}
 
 
ll sum(int v, int tl, int tr, int l, int r) {
    if (l > r) 
        return 0;
    if (l == tl && r == tr) {
        return t[v];
    }
    int tm = (tl + tr) / 2;
    return sum(v*2, tl, tm, l, min(r, tm))
           + sum(v*2+1, tm+1, tr, max(l, tm+1), r);
}
 
void update(int v, int tl, int tr, int pos, ll new_val) {
    if (tl == tr) {
        t[v] = new_val;
    } else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v*2, tl, tm, pos, new_val);
        else
            update(v*2+1, tm+1, tr, pos, new_val);
        t[v] = t[v*2] + t[v*2+1];
    }
}
\end{lstlisting}

\subsection{Segment Tree (Minimum query)}

\begin{lstlisting}[style=compactcpp]
ll  t[4*MAX];
 
// Shout-out to CP algo for the SegTree implementation: https://cp-algorithms.com/data_structures/segment_tree.html#memory-efficient-implementation
 
void buildSegTree(vector<ll> &a, int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
    } else {
        int tm = (tl + tr) / 2;
        buildSegTree(a, v*2, tl, tm);
        buildSegTree(a, v*2+1, tm+1, tr);
        t[v] = min(t[v*2], t[v*2+1]); // Change to minimum
    }
}
 
 
ll query(int v, int tl, int tr, int l, int r) {
    if (l > r) 
        return LLONG_MAX; // Return maximum possible value for empty range
    if (l == tl && r == tr) {
        return t[v];
    }
    int tm = (tl + tr) / 2;
    return min(query(v*2, tl, tm, l, min(r, tm)),
               query(v*2+1, tm+1, tr, max(l, tm+1), r));
}
 
void update(int v, int tl, int tr, int pos, ll new_val) {
    if (tl == tr) {
        t[v] = new_val;
    } else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v*2, tl, tm, pos, new_val);
        else
            update(v*2+1, tm+1, tr, pos, new_val);
        t[v] = min(t[v*2], t[v*2+1]); // Change to minimum
    }
}
 
\end{lstlisting}

\subsection{Segment Tree Lazy Propagation Set and Sum}

\begin{lstlisting}[style=compactcpp]
enum QueryType{ ADD, SET, NONE };

struct Query{
    QueryType type = NONE;
    ll val = 0;
};

template <typename T> class LazySegTree {
    private:
        const int n;
        vector<T> tree;
        vector<Query> lazy;
        
        void build(int v, int l, int r, const vector<T> &a){
            if(l==r) tree[v] = a[l];
            else{
                int m = (l+r)/2;
                build(2*v, l, m, a);
                build(2*v+1, m+1, r, a);
                tree[v] = tree[2*v] + tree[2*v+1];
            }
        }

        void apply(int v, int len, const Query &x){
            if(x.type == ADD){
                if(lazy[v].type != SET)
                    lazy[v] = Query{ADD, lazy[v].val + x.val};
                else
                    lazy[v] = Query{SET, lazy[v].val + x.val};

                tree[v] += x.val*len;
            }else if(x.type == SET){
                tree[v] = x.val*len;
                lazy[v] = x;
            }
        }

        void push(int v, int l, int r){
            int m = (l+r)/2;
            apply(2*v, m-l+1, lazy[v]);
            apply(2*v+1, r-m, lazy[v]);
            lazy[v] = Query();
        }

        void update(int v, int l, int r, int ql, int qr, const Query &x){
            if(qr < l or ql > r) return;

            if(ql<=l and r <= qr) apply(v,r-l+1,x);
            else{
                push(v,l,r);
                int m = (l+r)/2;
                update(2*v,l,m,ql,qr,x);
                update(2*v+1,m+1,r,ql,qr,x);
                tree[v] = tree[2*v] + tree[2*v+1];
            }
        }

        T query(int v, int l, int r, int ql, int qr){
            if(qr < l || ql > r) return 0;
            if(l>=ql and r<=qr) return tree[v];
            push(v,l,r);
            int m = (l+r)/2;
            
            return query(2*v, l, m, ql, qr) + query(2*v+1,m+1,r,ql,qr);
        }

    public:
        LazySegTree(const vector<T> &a) : n(a.size()), tree(4 * n), lazy(4 * n){
            build(1, 0, n - 1, a);
        }

        void update(int ql, int qr, const Query &x){
            update(1,0, n-1,ql,qr,x);
        }

        T query(int ql, int qr){ return query(1,0,n-1,ql,qr);};

};
\end{lstlisting}

\subsection{Lazy Segment Tree (Range Max/Min Query and Range Update)}

\begin{lstlisting}[style=compactcpp]
// Lazy Segment Tree for range maximum queries with range updates
// Supports: adding a value to all elements in a range, querying max in a range
enum QueryType{ MAX, NONE };

struct Query{
    QueryType type = NONE;
    ll val = 0;
};

template <typename T> class LazySegTree {
    private:
        const int n;
        vector<T> tree;
        vector<Query> lazy;
        
        void build(int v, int l, int r, const vector<T> &a){
            if(l==r) tree[v] = a[l];
            else{
                int m = (l+r)/2;
                build(2*v, l, m, a);
                build(2*v+1, m+1, r, a);
                tree[v] = max(tree[2*v], tree[2*v+1]);
            }
        }

        void apply(int v, int len, const Query &x){
            tree[v] += x.val;
            lazy[v].val += x.val;
            lazy[v].type = MAX;
        }

        void push(int v, int l, int r){
            int m = (l+r)/2;
            apply(2*v, m-l+1, lazy[v]);
            apply(2*v+1, r-m, lazy[v]);
            lazy[v] = Query();
        }

        void update(int v, int l, int r, int ql, int qr, const Query &x){
            if(qr < l or ql > r) return;

            if(ql<=l and r <= qr) apply(v,r-l+1,x);
            else{
                push(v,l,r);
                int m = (l+r)/2;
                update(2*v,l,m,ql,qr,x);
                update(2*v+1,m+1,r,ql,qr,x);
                tree[v] = max(tree[2*v], tree[2*v+1]);
            }
        }

        T query(int v, int l, int r, int ql, int qr){
            if(qr < l || ql > r) return LLONG_MIN;
            if(l>=ql and r<=qr) return tree[v];
            push(v,l,r);
            int m = (l+r)/2;
            
            return max(query(2*v, l, m, ql, qr), query(2*v+1,m+1,r,ql,qr));
        }

    public:
        LazySegTree(const vector<T> &a) : n(a.size()-1), tree(8 * (a.size()-1)), lazy(8 * (a.size()-1)){
            build(1, 0, n, a);
        }

        void update(int ql, int qr, const Query &x){
            update(1,0, n,ql,qr,x);
        }

        T query(int ql, int qr){ return query(1,0,n,ql,qr);};

};

\end{lstlisting}

\subsection{Segment Tree 2D}

\begin{lstlisting}[style=compactcpp]
typedef long long ll;
typedef vector<int> vec;
const ll mod=1e9+7;
const int TAM=1e3+1;
//ascii https://elcodigoascii.com.ar/
vector<vector<int>> forest(TAM,vector<int> (TAM));
ll t[4*TAM][4*TAM];
int n;

void buildNode(int root,int l,int r,int node,vector<int> &arr){
    if(l==r)
    {
        t[node][root]=arr[l];
        return;
    }
    int mid=(l+r)/2;
    buildNode(2*root,l,mid,node,arr);
    buildNode(2*root+1,mid+1,r,node,arr);
    t[node][root]=t[node][2*root]+t[node][2*root+1];
}

void build(int root,int l,int r,vector<vector<int>> &arr)
{
    if(l==r)
    {
        buildNode(1,0,n-1,root,arr[l]);
        return;
    }
    int mid=(l+r)/2;
    build(2*root,l,mid,arr);
    build(2*root+1,mid+1,r,arr);
    FO(i,4*TAM) t[root][i]=t[2*root][i]+t[2*root+1][i];
    
}

void updateNode(int root,int l,int r,int y,int node,int val)
{
    if(l==r)
    {
        t[node][root]=val;
        return;
    }
    int mid=(l+r)/2;
    if(y>mid)
    {
        updateNode(2*root+1,mid+1,r,y,node,val);
    }
    else{
        updateNode(2*root,l,mid,y,node,val);
    }
    t[node][root]=t[node][2*root]+t[node][2*root+1];
}

void update(int root,int l,int r,int x,int y,int val)
{
    if(l==r)
    {
        updateNode(1,0,n-1,y,root,val);
        return;
    }
    int mid=(l+r)/2;
    if(x>mid)
    {
        update(2*root+1,mid+1,r,x,y,val);
    }
    else{
        update(2*root,l,mid,x,y,val);
    }
    int i=0,j=n-1,Ndt=1,mid_aux;
    while(i!=j)
    {
        mid_aux=(i+j)/2;
        t[root][Ndt]=t[2*root][Ndt]+t[2*root+1][Ndt];
        if(y>mid_aux){
            i=mid_aux+1;
            Ndt=2*Ndt+1;
        } 
        else{
            j=mid_aux;
            Ndt*=2;
        } 
    }
    t[root][Ndt]=t[2*root][Ndt]+t[2*root+1][Ndt];
}

ll consultNode(int root,int l,int r,int node,int y1,int y2)
{
    if(y1>y2) return 0;
    if(l==y1 && r==y2) return t[node][root];
    int mid=(l+r)/2;
    return consultNode(2*root,l,mid,node,y1,min(y2,mid))+
    consultNode(2*root+1,mid+1,r,node,max(mid+1,y1),y2);
}

ll consult(int root,int l,int r, int x1,int x2,int y1,int y2)
{
    if(x1>x2) return 0;
    if(l==x1 && r==x2) return consultNode(1,0,n-1,root,y1,y2);
    int mid=(l+r)/2;
    return consult(2*root,l,mid,x1,min(x2,mid),y1,y2)+
    consult(2*root+1,mid+1,r,max(mid+1,x1),x2,y1,y2);
}

\end{lstlisting}

\subsection{Segment Tree 2D (Iterative, Class-based)}

\begin{lstlisting}[style=compactcpp]
// 2D Segment Tree (Iterative): efficient range sum queries and point updates on 2D grid
// Build in O(n*m), Query and Update in O(log n * log m)
class SegmentTree2D{
private:
    vector<vector<int>> segtree;
    int n;
    int m;
    int d1;
    int d2;
 
public:
 
    void build(vector<vector<int>> &a){
        n = a.size();
        m = a[0].size();
        d1=1;
        while(d1<n) d1<<=1;
        
        d2=1;
        while(d2<m) d2<<=1;
 
        segtree.assign(2*d1, vector<int>(2*d2,0));
 
        // Set leaves
        for(int i=0; i<n; i++)
            for(int j=0; j<m; j++)
                segtree[d1+i][d2+j] = a[i][j];
        
        // Propagate on columns
        for(int i=d1; i<2*d1; i++){
            for(int j=d2-1; j>0; j--)
                segtree[i][j] = segtree[i][2*j] + segtree[i][2*j+1];
        }
 
        // Propagate on rows
        for(int i=d1-1; i>0; i--){
            for(int j=1; j<2*d2; j++)
                segtree[i][j] = segtree[2*i][j] + segtree[2*i+1][j];
        }
    }
 
    void update(int x, int y, int k){
        int r = x + d1;
        int c = y + d2;
 
        segtree[r][c] = k;
 
        // Update columns for the row corresponding to x
        for(int j=c>>1; j>0; j>>=1)
            segtree[r][j] = segtree[r][2*j] + segtree[r][2*j+1];
 
        
        for(int i=r>>1; i>0; i>>=1){
            segtree[i][c] = segtree[2*i][c] + segtree[2*i+1][c];
            for(int j=c>>1; j>0; j>>=1)
                segtree[i][j] = segtree[i][2*j] + segtree[i][2*j+1];
        }
    }
 
 
 
    int query(int x1, int y1, int x2, int y2){
        int lx = x1+d1, rx = x2+d1+1;
        
        ll arns = 0;
        while(lx<rx) {
            if(lx & 1){
                arns += query_y(lx, y1, y2);
                ++lx;
            }
            if (rx & 1){
                --rx;
                arns += query_y(rx, y1, y2);
            }
            lx >>= 1; rx >>= 1;
        }
        return arns;
    }
 
    int query_y(int row, int y1, int y2) {
        int ly = y1 + d2, ry = y2 + 1 + d2;
        int s = 0;
        while (ly < ry) {
            if(ly & 1) s+=segtree[row][ly++];
            if(ry & 1) s+=segtree[row][--ry];
            ly >>= 1; ry >>= 1;
        }
        return s;
    }
 
};
\end{lstlisting}

\subsection{Inverted Segment Tree}

\begin{lstlisting}[style=compactcpp]
class InvertedSegmentTree{
private:
    ll segtree[4*100000+5];
    int n;

public:

    SegmentTree(vector<ll> &a, int n){
        this->n = n;

        for(int i=0; i<n; i++)
            this->segtree[n+i] = a[i];
    
        for(int i=n-1; i>=1; i--)
            this->segtree[i] = this->segtree[2*i]+ this->segtree[2*i+1];
    }

    // Range update
    void update(int l, int r, ll k){
        while(l<=r){
            if(l%2 == 1) this->segtree[l++]+=value;
            if(r%2 == 0) this->segtree[r--]+=value;
            l>>=1;
            r>>=1;
        }
    }

    // Point query
    ll query(int p){
        int arns = 0;
        for(p+=n; p>0; p>>=1) arns+=this->segtree[p];
        return arns;
    }

    // Range query
    ll query(int l, int r){
        l+=this->n;
        r+=this->n;
    
        ll zum = 0;
    
        while(l<=r){
            if(l%2 == 1) zum += this->segtree[l++];
            if(r%2 == 0) zum += this->segtree[r--];
            l>>=1;
            r>>=1;
        }
    
        return zum;
    }


};
\end{lstlisting}

\subsection{Segment tree with Index Compression}

\begin{lstlisting}[style=compactcpp]
typedef long long ll;
typedef vector<int> vec;
typedef vector<pair<int,int>> vpii;
const ll mod=1e9+7;
const int MAX=4e5+3;
const int limit=2e5+3;
const int TAM=2e5+1;
ll t[4*MAX];
//ascii https://elcodigoascii.com.ar/


void update(int root,int l,int r,int pos,int val)
{
    if(l==r)
    {
        t[root]+=val;
        return;
    }
    int mid=(l+r)/2;
    if(pos>mid)
    {
        update(2*root+1,mid+1,r,pos,val);
    }
    else{
        update(2*root,l,mid,pos,val);
    }
    t[root]=t[2*root]+t[2*root+1];
}

ll consult(int root,int l,int r, int a,int b)
{
    if(a>b) return 0;
    if(l==a && r==b) return t[root];
    int mid=(l+r)/2;
    return consult(2*root,l,mid,a,min(b,mid))+
    consult(2*root+1,mid+1,r,max(mid+1,a),b);
}

inline void solve()
{
   int n,m,index;
   cin>>n>>m;
   vector<ll> arr(n);
   vector<tuple<char,ll,ll>> queries(m);
   set<ll> salary;
   memset(t,0,sizeof(t));
   FO(i,n){
        ll aux; cin>>aux;
        arr[i]=aux;
        salary.insert(aux);
   } 
   FO(i,m)
   {
        char a; 
        ll b,c;
        cin>>a>>b>>c;
        queries[i]=make_tuple(a,b,c);
        if(a=='!') salary.insert(c);
   } 
   
   vector<ll> coord(all(salary));
   int tn=coord.size();
   //FO(i,tn) cout<<coord[i]<<" ";
   //cout<<endl;
   FO(i,n)
   {
        index=lower_bound(all(coord),arr[i])-coord.begin();
        update(1,0,tn-1,index,1);
   }
   FO(i,m)
   {
        char a=get<0>(queries[i]);
        ll b=get<1>(queries[i]);
        ll c=get<2>(queries[i]);
        if(a=='?'){
            b=lower_bound(all(coord),b)-coord.begin();
            c=(upper_bound(all(coord),c)-coord.begin())-1;
            if(b==tn || c==tn ){
                cout<<0<<endl;
            }
            else cout<<consult(1,0,tn-1,b,c)<<endl;
        }
        else{
            index=lower_bound(all(coord),arr[b-1])-coord.begin();
            update(1,0,tn-1,index,-1);
            arr[b-1]=c;
            index=lower_bound(all(coord),arr[b-1])-coord.begin();
            update(1,0,tn-1,index,1);
            
        }
   }

}

\end{lstlisting}

\subsection{Segment Tree Preffix-Suffix-Biggest}

\begin{lstlisting}[style=compactcpp]
typedef long long ll;
typedef vector<int> vec;
typedef vector<pair<int,int>> vpii;
const ll mod=1e9+7;
const int MAX=1e5+3;
const int limit=2e5+3;
const int TAM=2e5+1;
ll t[4*TAM];
ll prefix[4*TAM],suffix[4*TAM],biggest[4*TAM];
//ascii https://elcodigoascii.com.ar/
ll cero=0;
void build(int root,int l,int r,vector<ll> &arr)
{
    if(l==r)
    {
        t[root]=arr[l];
        suffix[root]=max(t[root],cero);
        prefix[root]=max(t[root],cero);
        biggest[root]=max(t[root],cero);
        return;
    }
    int mid=(l+r)/2;
    build(2*root,l,mid,arr);
    build(2*root+1,mid+1,r,arr);
    t[root]=t[2*root]+t[2*root+1];
    biggest[root]=max(biggest[2*root],
    max(biggest[2*root+1],suffix[2*root]+prefix[2*root+1]));
    prefix[root]=max(prefix[2*root],t[2*root]+prefix[2*root+1]);
    suffix[root]=max(suffix[2*root+1],t[2*root+1]+suffix[2*root]);
    
}

void update(int root,int l,int r,int pos,ll val)
{
    if(l==r)
    {
        t[root]=val;
        suffix[root]=max(cero,t[root]);
        prefix[root]=max(cero,t[root]);
        biggest[root]=max(t[root],cero);
        return;
    }
    int mid=(l+r)/2;
    if(pos>mid)
    {
        update(2*root+1,mid+1,r,pos,val);
    }
    else{
        update(2*root,l,mid,pos,val);
    }
    t[root]=t[2*root]+t[2*root+1];
    biggest[root]=max(biggest[2*root],
    max(biggest[2*root+1],suffix[2*root]+prefix[2*root+1]));
    prefix[root]=max(prefix[2*root],t[2*root]+prefix[2*root+1]);
    suffix[root]=max(suffix[2*root+1],t[2*root+1]+suffix[2*root]);
}

ll consult(int root,int l,int r, int a,int b)
{
    if(a>b) return 0;
    if(l==a && r==b) return t[root];
    int mid=(l+r)/2;
    return consult(2*root,l,mid,a,min(b,mid))+
    consult(2*root+1,mid+1,r,max(mid+1,a),b);
}
\end{lstlisting}

\subsection{Segment Tree Maximum Subarray (Class-based)}

\begin{lstlisting}[style=compactcpp]
// Segment Tree for maximum subarray sum queries with point updates
// Maintains prefix max, suffix max, total sum, and overall max for each segment
typedef struct Node{
    ll u,l,r,zum;
    Node(){
        u = INT_MIN, l = INT_MIN, r=INT_MIN, zum = 0;
    }
 
    Node(ll a, ll b, ll c, ll d){
        u = a;
        l = b;
        r = c;
        zum = d;
    }
};
 
class SegmentTree{
    private:
        vector<Node> segtree;
        int n;
        int d;
    
    public:
        Node combine(Node a, Node b){
            ll u = max({a.u,b.u,a.r+b.l});
            ll l = max(a.l,b.l + a.zum);
            ll r = max(a.r+b.zum, b.r);
            ll zum = a.zum + b.zum;
 
            return Node(u,l,r,zum);
        }
        void build(vector<int> &a){
            n = a.size();
            d=1;
            while(d<n) d<<=1;
            segtree.assign(2*d, Node());
            for(int i=0; i<n; i++){
                segtree[d+i].u = max(a[i], 0);
                segtree[d+i].l = max(a[i],0);
                segtree[d+i].r = max(a[i], 0);
                segtree[d+i].zum = a[i];
            }
                
            for(int i=d-1; i>=1; i--)
                segtree[i] = combine(segtree[2*i], segtree[2*i+1]);
            
            
        }
 
        void update(int pos, int k){
            pos+=d;
            segtree[pos].u = max(0,k);
            segtree[pos].l = max(0,k);
            segtree[pos].r = max(0,k);
            segtree[pos].zum = k;
            
            while(pos>1){ 
                pos>>=1; 
                segtree[pos] = combine(segtree[2*pos], segtree[2*pos+1]);
            }
        }
        
        ll query(){
            return segtree[1].u;
        }
 
};
\end{lstlisting}

\subsection{Persistent Array}

\begin{lstlisting}[style=compactcpp]
vector<pair<int, int>> arr[100001];  // The persistent array

int get_item(int index, int time) {
	// Gets the array item at a given index and time
	auto ub =
	    upper_bound(arr[index].begin(), arr[index].end(), make_pair(time, INT_MAX));
	return prev(ub)->second;
}

void update_item(int index, int value, int time) {
	// Updates the array item at a given index and time
	// Note that this only works if the time is later than all previous
	// update times
	assert(arr[index].back().first < time);
	arr[index].push_back({time, value});
}

void init_arr(int n, int *init) {
	// Initializes the persistent array, given an input array
	for (int i = 0; i < n; i++) arr[i].push_back({0, init[i]});
}
\end{lstlisting}


\subsection{Path Copying - Persistent Array}


\begin{lstlisting}[style=compactcpp]
    	struct Node {
	int val;
	Node *l, *r;

	Node(ll x) : val(x), l(nullptr), r(nullptr) {}
	Node(Node *ll, Node *rr) : val(0), l(ll), r(rr) {}
};

int n, a[100001];     // The initial array and its size
Node *roots[100001];  // The persistent array's roots

Node *build(int l = 0, int r = n - 1) {
	if (l == r) return new Node(a[l]);
	int mid = (l + r) / 2;
	return new Node(build(l, mid), build(mid + 1, r));
}

Node *update(Node *node, int val, int pos, int l = 0, int r = n - 1) {
	if (l == r) return new Node(val);
	int mid = (l + r) / 2;
	if (pos > mid) return new Node(node->l, update(node->r, val, pos, mid + 1, r));
	else return new Node(update(node->l, val, pos, l, mid), node->r);
}

int query(Node *node, int pos, int l = 0, int r = n - 1) {
	if (l == r) return node->val;
	int mid = (l + r) / 2;
	if (pos > mid) return query(node->r, pos, mid + 1, r);
	return query(node->l, pos, l, mid);
}

int get_item(int index, int time) {
	// Gets the array item at a given index and time
	return query(roots[time], index);
}

void update_item(int index, int value, int prev_time, int curr_time) {
	// Updates the array item at a given index and time
	roots[curr_time] = update(roots[prev_time], index, value);
}

void init_arr(int nn, int *init) {
	// Initializes the persistent array, given an input array
	n = nn;
	for (int i = 0; i < n; i++) a[i] = init[i];
	roots[0] = build();
}
\end{lstlisting}

\subsection{Persistent Segment Tree}

\begin{lstlisting}[style=compactcpp]
using ll = long long;

class PersistentSegtree {
  private:
	struct Node {
		ll sum = 0;
		int l = 0, r = 0;
	};

	const int n;
	vector<Node> tree;
	int timer = 1;

	Node join(int l, int r) { return Node{tree[l].sum + tree[r].sum, l, r}; }

	int build(int tl, int tr, const vector<int> &arr) {
		if (tl == tr) {
			tree[timer] = {arr[tl], 0, 0};
			return timer++;
		}

		int mid = (tl + tr) / 2;
		tree[timer] = join(build(tl, mid, arr), build(mid + 1, tr, arr));

		return timer++;
	}

	int set(int v, int pos, int val, int tl, int tr) {
		if (tl == tr) {
			tree[timer] = {val, 0, 0};
			return timer++;
		}

		int mid = (tl + tr) / 2;
		if (pos <= mid) {
			tree[timer] = join(set(tree[v].l, pos, val, tl, mid), tree[v].r);
		} else {
			tree[timer] = join(tree[v].l, set(tree[v].r, pos, val, mid + 1, tr));
		}

		return timer++;
	}

	ll range_sum(int v, int ql, int qr, int tl, int tr) {
		if (qr < tl || tr < ql) { return 0ll; }
		if (ql <= tl && tr <= qr) { return tree[v].sum; }

		int mid = (tl + tr) / 2;
		return range_sum(tree[v].l, ql, qr, tl, mid) +
		       range_sum(tree[v].r, ql, qr, mid + 1, tr);
	}

  public:
	PersistentSegtree(int n, int MX_NODES) : n(n), tree(MX_NODES) {}

	int build(const vector<int> &arr) { return build(0, n - 1, arr); }

	int set(int root, int pos, int val) { return set(root, pos, val, 0, n - 1); }

	ll range_sum(int root, int l, int r) { return range_sum(root, l, r, 0, n - 1); }

	int add_copy(int root) {
		tree[timer] = tree[root];
		return timer++;
	}
};
\end{lstlisting}

\subsection{Policy Ordered Set}

\begin{lstlisting}[style=compactcpp]
#include <ext/pb_ds/assoc_container.hpp> // Common file
#include <ext/pb_ds/tree_policy.hpp>
#include <functional> // for less
using namespace __gnu_pbds;

// To allow repetitions
typedef tree<int, null_type, less<int>, rb_tree_tag,
             tree_order_statistics_node_update>
    ordered_set;

// To not allow repetitions
typedef tree<pair<int, int>, null_type,
             less<pair<int, int> >, rb_tree_tag,
             tree_order_statistics_node_update>
    ordered_multiset;

ordered_set pt; // Definition

pt.order_of_key(x); // Number of items strictly smaller than x
pt.find_by_order(k); // Iterator to the kth element

\end{lstlisting}

\subsection{Disjoint Set Union}

\begin{lstlisting}[style=compactcpp]
// Shout-out to Usaco Guide for DSU implementation: https://usaco.guide/gold/dsu?lang=cpp
 
class DisjointSets{
    private:
        vector<int> parents;
        vector<int> sizes;
        int components;
    public:
        DisjointSets(int size) : parents(size), sizes(size,1), components(size){
            for(int i=0; i<size; i++){parents[i] = i;}
        }

        int find(int x) {return parents[x] == x ? x : (parents[x] = find(parents[x]));}

        bool unite(int x, int y){
            int x_root = find(x);
            int y_root = find(y);

            if(x_root == y_root) {return false;}

            if(sizes[x_root] < sizes[y_root]) {swap(x_root,y_root);}
            sizes[x_root] += sizes[y_root];
            parents[y_root] = x_root;
            components--;
            return true;
        }

        vector<int> getAllComponentSizes(){
            map<int, int> component_sizes;
            for (int i = 0; i < parents.size(); ++i){
                int root = find(i);
                if (component_sizes.find(root) == component_sizes.end()){
                    component_sizes[root] = sizes[root];
                }
            }

            vector<int> result;
            for (auto& [root, size] : component_sizes) {
                result.push_back(size);
            }

            return result;
        }


        bool connected(int x, int y) { return find(x) == find(y);}
        int getSize(int x) {return sizes[find(x)];}
        int getComponents() const {return components;}
};
\end{lstlisting}

\subsection{DSU to detect cycles}

\begin{lstlisting}[style=compactcpp]
class CycleDetectionDSU {
    vector<int> parent;
    vector<int> size;

public:
    CycleDetectionDSU(int n) : parent(n), size(n, 1) {
        iota(parent.begin(), parent.end(), 0);
    }

    int find(int x) {
        return parent[x] == x ? x : parent[x] = find(parent[x]);
    }

    // Returns true if adding edge u-v creates a cycle
    bool add_edge(int u, int v) {
        int u_root = find(u);
        int v_root = find(v);
        if (u_root == v_root) return true;
        
        if (size[u_root] < size[v_root]) swap(u_root, v_root);
        parent[v_root] = u_root;
        size[u_root] += size[v_root];
        return false;
    }
};
\end{lstlisting}

\subsection{DSU to check online bipartitness}

\begin{lstlisting}[style=compactcpp]
class BipartiteDSU {
    vector<int> parent;
    vector<int> size;

public:
    BipartiteDSU(int n) : parent(2*n), size(2*n, 1) {
        iota(parent.begin(), parent.end(), 0);
    }

    int find(int x) {
        return parent[x] == x ? x : parent[x] = find(parent[x]);
    }

    // Returns true if graph remains bipartite after adding u-v
    bool add_edge(int u, int v) {
        int u_orig = 2*u;      // Original node
        int u_mirror = 2*u+1;  // Mirror node
        int v_orig = 2*v;
        int v_mirror = 2*v+1;

        // Union u_orig <-> v_mirror and v_orig <-> u_mirror
        for(int i = 0; i < 2; i++) {
            int x = i ? v_orig : u_orig;
            int y = i ? u_mirror : v_mirror;
            
            int x_root = find(x);
            int y_root = find(y);
            if (x_root != y_root) {
                if (size[x_root] < size[y_root]) swap(x_root, y_root);
                parent[y_root] = x_root;
                size[x_root] += size[y_root];
            }
        }

        // Check if u is in both partitions
        return find(u_orig) != find(u_mirror);
    }
};


// -- Other implementation --

void make_set(int v) {
    parent[v] = make_pair(v, 0);
    rank[v] = 0;
    bipartite[v] = true;
}

pair<int, int> find_set(int v) {
    if (v != parent[v].first) {
        int parity = parent[v].second;
        parent[v] = find_set(parent[v].first);
        parent[v].second ^= parity;
    }
    return parent[v];
}

void add_edge(int a, int b) {
    pair<int, int> pa = find_set(a);
    a = pa.first;
    int x = pa.second;

    pair<int, int> pb = find_set(b);
    b = pb.first;
    int y = pb.second;

    if (a == b) {
        if (x == y)
            bipartite[a] = false;
    } else {
        if (rank[a] < rank[b])
            swap (a, b);
        parent[b] = make_pair(a, x^y^1);
        bipartite[a] &= bipartite[b];
        if (rank[a] == rank[b])
            ++rank[a];
    }
}

bool is_bipartite(int v) {
    return bipartite[find_set(v).first];
}

\end{lstlisting}

\subsection{DSU with rollback}

\begin{lstlisting}[style=compactcpp]
class DSU {
  private:
	vector<int> p, sz;
	// stores previous unites
	vector<pair<int &, int>> history;

  public:
	DSU(int n) : p(n), sz(n, 1) { iota(p.begin(), p.end(), 0); }

	int get(int x) { return x == p[x] ? x : get(p[x]); }

	void unite(int a, int b) {
		a = get(a);
		b = get(b);
		if (a == b) { return; }
		if (sz[a] < sz[b]) { swap(a, b); }

		// save this unite operation
		history.push_back({sz[a], sz[a]});
		history.push_back({p[b], p[b]});

		p[b] = a;
		sz[a] += sz[b];
	}

	int snapshot() { return history.size(); }

	void rollback(int until) {
		while (snapshot() > until) {
			history.back().first = history.back().second;
			history.pop_back();
		}
	}
};

\end{lstlisting}

\subsection{Dynamic connectivity}

\begin{lstlisting}[style=compactcpp]
struct dsu_save {
    int v, rnkv, u, rnku;

    dsu_save() {}

    dsu_save(int _v, int _rnkv, int _u, int _rnku)
        : v(_v), rnkv(_rnkv), u(_u), rnku(_rnku) {}
};

struct dsu_with_rollbacks {
    vector<int> p, rnk;
    int comps;
    stack<dsu_save> op;

    dsu_with_rollbacks() {}

    dsu_with_rollbacks(int n) {
        p.resize(n);
        rnk.resize(n);
        for (int i = 0; i < n; i++) {
            p[i] = i;
            rnk[i] = 0;
        }
        comps = n;
    }

    int find_set(int v) {
        return (v == p[v]) ? v : find_set(p[v]);
    }

    bool unite(int v, int u) {
        v = find_set(v);
        u = find_set(u);
        if (v == u)
            return false;
        comps--;
        if (rnk[v] > rnk[u])
            swap(v, u);
        op.push(dsu_save(v, rnk[v], u, rnk[u]));
        p[v] = u;
        if (rnk[u] == rnk[v])
            rnk[u]++;
        return true;
    }

    void rollback() {
        if (op.empty())
            return;
        dsu_save x = op.top();
        op.pop();
        comps++;
        p[x.v] = x.v;
        rnk[x.v] = x.rnkv;
        p[x.u] = x.u;
        rnk[x.u] = x.rnku;
    }
};

struct query {
    int v, u;
    bool united;
    query(int _v, int _u) : v(_v), u(_u) {
    }
};

struct QueryTree {
    vector<vector<query>> t;
    dsu_with_rollbacks dsu;
    int T;

    QueryTree() {}

    QueryTree(int _T, int n) : T(_T) {
        dsu = dsu_with_rollbacks(n);
        t.resize(4 * T + 4);
    }

    void add_to_tree(int v, int l, int r, int ul, int ur, query& q) {
        if (ul > ur)
            return;
        if (l == ul && r == ur) {
            t[v].push_back(q);
            return;
        }
        int mid = (l + r) / 2;
        add_to_tree(2 * v, l, mid, ul, min(ur, mid), q);
        add_to_tree(2 * v + 1, mid + 1, r, max(ul, mid + 1), ur, q);
    }

    void add_query(query q, int l, int r) {
        add_to_tree(1, 0, T - 1, l, r, q);
    }

    void dfs(int v, int l, int r, vector<int>& ans) {
        for (query& q : t[v]) {
            q.united = dsu.unite(q.v, q.u);
        }
        if (l == r)
            ans[l] = dsu.comps;
        else {
            int mid = (l + r) / 2;
            dfs(2 * v, l, mid, ans);
            dfs(2 * v + 1, mid + 1, r, ans);
        }
        for (query q : t[v]) {
            if (q.united)
                dsu.rollback();
        }
    }

    vector<int> solve() {
        vector<int> ans(T);
        dfs(1, 0, T - 1, ans);
        return ans;
    }
}
\end{lstlisting}

\subsection{Trie}

\begin{lstlisting}[style=compactcpp]
class TrieNode
{
  public:
    // Array for children nodes of each node
    TrieNode *children[26];

    // for end of word
    bool isLeaf;

    TrieNode()
    {
        isLeaf = false;
        for (int i = 0; i < 26; i++)
        {
            children[i] = nullptr;
        }
    }

};
  // Method to insert a key into the Trie
void insert(TrieNode *root, const string &key)
{

    // Initialize the curr pointer with the root node
    TrieNode *curr = root;

    // Iterate across the length of the string
    for (char c : key)
    {

        // Check if the node exists for the
        // current character in the Trie
        if (curr->children[c - 'a'] == nullptr)
        {

            // If node for current character does
            // not exist then make a new node
            TrieNode *newNode = new TrieNode();

            // Keep the reference for the newly
            // created node
            curr->children[c - 'a'] = newNode;
        }

        // Move the curr pointer to the
        // newly created node
        curr = curr->children[c - 'a'];
    }

    // Mark the end of the word
    curr->isLeaf = true;
}

// Method to search a key in the Trie
bool search(TrieNode *root, const string &key)
{

    if (root == nullptr)
    {
        return false;
    }

    // Initialize the curr pointer with the root node
    TrieNode *curr = root;

    // Iterate across the length of the string
    for (char c : key)
    {

        // Check if the node exists for the
        // current character in the Trie
        if (curr->children[c - 'a'] == nullptr)
            return false;

        // Move the curr pointer to the
        // already existing node for the
        // current character
        curr = curr->children[c - 'a'];
    }

    // Return true if the word exists
    // and is marked as ending
    return curr->isLeaf;
}

// Method to check if a prefix exists in the Trie
bool isPrefix(TrieNode *root, const string &prefix)
{
    // Initialize the curr pointer with the root node
    TrieNode *curr = root;

    // Iterate across the length of the prefix string
    for (char c : prefix)
    {
        // Check if the node exists for the current character in the Trie
        if (curr->children[c - 'a'] == nullptr)
            return false;

        // Move the curr pointer to the already existing node
        // for the current character
        curr = curr->children[c - 'a'];
    }

    // If we reach here, the prefix exists in the Trie
    return true;
  }
\end{lstlisting}

\subsection{Trie (Class-based with DP)}

\begin{lstlisting}[style=compactcpp]
// Trie data structure with insert, search, prefix checking, and DP for string formation
// arnsDP: counts ways to form string s using words in the trie (word break problem)
class Trie{
private:
    Trie *children[26];
    bool term_st; // is_end
 
    Trie* searchPrefix(const string &p){
        Trie* node = this;
 
        for(char c:p){
            int pos = c - 'a';
            if(!node->children[pos]) return nullptr;
            node = node->children[pos];
        }
        return node;
    }
 
public:
    Trie() : term_st(false) {
        for(int i=0; i<26; i++)
            children[i] = nullptr;
    }
    
    void insert(string word) {
        Trie* node = this;
        for(char c:word){
            int pos = c - 'a';
            if(!node->children[pos]) node->children[pos] = new Trie();
            node = node->children[pos];
        }
 
        node->term_st = true;
    }
    
    bool search(string word) {
        Trie* node = searchPrefix(word);
        return node != nullptr && node->term_st;
    }
    
    bool startsWith(string prefix) {
        Trie* node = searchPrefix(prefix);
        return node != nullptr;
    }
 
    int arnsDP(string s, int n){
        vector<int> dp(n+1, 0);
        // dp[i] -> ways to form the prefix s[0..i-1]
        dp[0] = 1;
 
        for(int i = 0; i < n; i++){
            Trie *it = this; // Iterate the Trie from the root
            for(int j = i; j < n; j++){
                int pos = s[j] - 'a';
                if(!it->children[pos]) break;
                it = it->children[pos];
 
                if(it->term_st)
                    dp[j+1] = (dp[j+1] + dp[i]) % MOD;
                
            }
        }
        return dp[n];
    }
};
\end{lstlisting}

\subsection{Palindromic Tree}

\begin{lstlisting}[style=compactcpp]
const int MAXN = 105000;

struct node {
    int next[26];
    int len;
    int sufflink;
    int num;
};

int len;
char s[MAXN];
node tree[MAXN]; 
int num;            // node 1 - root with len -1, node 2 - root with len 0
int suff;           // max suffix palindrome
long long ans;

bool addLetter(int pos) {
    int cur = suff, curlen = 0;
    int let = s[pos] - 'a';

    while (true) {
        curlen = tree[cur].len;
        if (pos - 1 - curlen >= 0 && s[pos - 1 - curlen] == s[pos])     
            break;  
        cur = tree[cur].sufflink;
    }       
    if (tree[cur].next[let]) {  
        suff = tree[cur].next[let];
        return false;
    }

    num++;
    suff = num;
    tree[num].len = tree[cur].len + 2;
    tree[cur].next[let] = num;

    if (tree[num].len == 1) {
        tree[num].sufflink = 2;
        tree[num].num = 1;
        return true;
    }

    while (true) {
        cur = tree[cur].sufflink;
        curlen = tree[cur].len;
        if (pos - 1 - curlen >= 0 && s[pos - 1 - curlen] == s[pos]) {
            tree[num].sufflink = tree[cur].next[let];
            break;
        }       
    }           

    tree[num].num = 1 + tree[tree[num].sufflink].num;

    return true;
}

void initTree() {
    num = 2; suff = 2;
    tree[1].len = -1; tree[1].sufflink = 1;
    tree[2].len = 0; tree[2].sufflink = 1;
}

// -- Other implementation --

const int maxn = 1e5, sigma = 26;
 
int s[maxn], len[maxn], link[maxn], to[maxn][sigma];
 
int n, last, sz;
 
void init()
{
    s[n++] = -1;
    link[0] = 1;
    len[1] = -1;
    sz = 2;
}
 
int get_link(int v)
{
    while(s[n - len[v] - 2] != s[n - 1]) v = link[v];
    return v;
}
 
void add_letter(int c)
{
    s[n++] = c;
    last = get_link(last);
    if(!to[last][c])
    {
        len [sz] = len[last] + 2;
        link[sz] = to[get_link(link[last])][c];
        to[last][c] = sz++;
    }
    last = to[last][c];
}
\end{lstlisting}

\subsection{Implicit Treap}

\begin{lstlisting}[style=compactcpp]
using namespace std;

#include<random>
#include<chrono>

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

#define ll long long

struct TreapNode{
    ll key, pr, sz;
    TreapNode *l, *r;
};

typedef TreapNode* Treap;

int getSize(Treap &t){
    return t ? t->sz : 0;
}

void updateSize(Treap &t){
    if (t) t->sz = 1 + getSize(t->l) + getSize(t->r);
}

void split(Treap& t, ll k, Treap &l, Treap  &r){
    if(not t) l = r = nullptr;

    else if(k < t->key){
        split(t->l,k,l, t->l);
        r = t;
        updateSize(r);
    }else{
        split(t->r,k,t->r,r);
        l = t;
        updateSize(l);
    }
}

void insert(Treap& t, Treap a){
    if(not t) t=a;
    else if(a->pr > t->pr){
        split(t, a->key, a->l, a->r);
        t = a;
    }else{
        if(a->key < t-> key) insert(t->l,a);
        else insert(t->r,a);
    }
    updateSize(t);
}

void merge(Treap &t, Treap l, Treap r){
    if(not l) t = r;
    else if(not r) t = l;

    else if(l->pr > r->pr){
        merge(l->r, l->r,r);
        t=l;
        updateSize(t);
    }else{
        merge(r->l,l,r->l);
        t=r;
        updateSize(t);
    }
}

void erase(Treap &t, ll k){
    if(not t) return;
    if(t->key == k) merge(t,t->l, t->r);
    
    else{
        if(k<t->key) erase(t->l,k);
        else erase(t->r, k);
    }
    updateSize(t);
}

bool find(Treap& t, ll k){
    if (not t) return false;
    if(t->key == k) return true;
    if(k<t->key) return find(t->l,k);
    return find(t->r,k);
}

void insertValue(Treap &t, ll k){
    if(not find(t,k)){
        Treap new_node = new TreapNode {k,rng(), 0,nullptr, nullptr};
        insert(t, new_node);
    }
}

ll getKth(Treap &t, int k){
    if(!t || k<=0 || k>getSize(t)) return 0;
    int leftSize = getSize(t->l);
    if(k == leftSize+1) return t->key;
    if(k <= leftSize) return getKth(t->l,k);
    return getKth(t->r, k-leftSize-1);
}
\end{lstlisting}

\subsection{Treap}

\begin{lstlisting}[style=compactcpp]
typedef struct item * pitem;
struct item {
    int prior, value, cnt;
    bool rev;
    pitem l, r;
};

int cnt (pitem it) {
    return it ? it->cnt : 0;
}

void upd_cnt (pitem it) {
    if (it)
        it->cnt = cnt(it->l) + cnt(it->r) + 1;
}

void push (pitem it) {
    if (it && it->rev) {
        it->rev = false;
        swap (it->l, it->r);
        if (it->l)  it->l->rev ^= true;
        if (it->r)  it->r->rev ^= true;
    }
}

void merge (pitem & t, pitem l, pitem r) {
    push (l);
    push (r);
    if (!l || !r)
        t = l ? l : r;
    else if (l->prior > r->prior)
        merge (l->r, l->r, r),  t = l;
    else
        merge (r->l, l, r->l),  t = r;
    upd_cnt (t);
}

void split (pitem t, pitem & l, pitem & r, int key, int add = 0) {
    if (!t)
        return void( l = r = 0 );
    push (t);
    int cur_key = add + cnt(t->l);
    if (key <= cur_key)
        split (t->l, l, t->l, key, add),  r = t;
    else
        split (t->r, t->r, r, key, add + 1 + cnt(t->l)),  l = t;
    upd_cnt (t);
}

void reverse (pitem t, int l, int r) {
    pitem t1, t2, t3;
    split (t, t1, t2, l);
    split (t2, t2, t3, r-l+1);
    t2->rev ^= true;
    merge (t, t1, t2);
    merge (t, t, t3);
}

void output (pitem t) {
    if (!t)  return;
    push (t);
    output (t->l);
    printf ("%d ", t->value);
    output (t->r);
}
\end{lstlisting}

\subsection{Treap with Lazy Propagation (Full Featured)}

\begin{lstlisting}[style=compactcpp]
// Treap with lazy propagation supporting multiple operations:
// insert, erase, query (sum/min/max), update, replace, reverse, cyclic shift
// 0-indexed array operations with O(log n) complexity
struct node {
    int val, sz, prior, lazy, sum, mx, mn, repl;
    bool repl_flag, rev;
    node *l, *r, *par;
    node() {
      lazy = 0;
      rev = 0;
      sum = 0;
      val = 0;
      sz = 0;
      mx = 0;
      mn = 0;
      repl = 0;
      repl_flag = 0;
      prior = 0;
      l = NULL;
      r = NULL;
      par = NULL;
    }
    node(int _val) {
      val = _val;
      sum = _val;
      mx = _val;
      mn = _val;
      repl = 0;
      repl_flag = 0;
      rev = 0;
      lazy = 0;
      sz = 1;
      prior = rnd();
      l = NULL;
      r = NULL;
      par = NULL;
    }
  };

struct treap {
  typedef node* pnode;
  pnode root;
  map<int, pnode> position;//positions of all the values
  //clearing the treap
  void clear() {
    root = NULL;
    position.clear();
  }

  treap() {
    clear();
  }

  int size(pnode t) {
    return t ? t->sz : 0;
  }
  void update_size(pnode &t) {
    if(t) t->sz = size(t->l) + size(t->r) + 1;
  }

  void update_parent(pnode &t) {
    if(!t) return;
    if(t->l) t->l->par = t;
    if(t->r) t->r->par = t;
  }
  //add operation
  void lazy_sum_upd(pnode &t) {
    if( !t or !t->lazy )    return;
    t->sum += t->lazy * size(t);
    t->val += t->lazy;
    t->mx += t->lazy;
    t->mn += t->lazy;
    if( t->l )  t->l->lazy += t->lazy;
    if( t->r )  t->r->lazy += t->lazy;
    t->lazy = 0;
  }
  //replace update
  void lazy_repl_upd(pnode &t) {
    if( !t or !t->repl_flag )   return;
    t->val = t->mx = t->mn = t->repl;
    t->sum = t->val * size(t);
    if( t->l ) {
      t->l->repl = t->repl;
      t->l->repl_flag = true;
    }
    if( t->r ) {
      t->r->repl = t->repl;
      t->r->repl_flag = true;
    }
    t->repl_flag = false;
    t->repl = 0;
  }
  //reverse update
  void lazy_rev_upd(pnode &t) {
    if( !t or !t->rev ) return;
    t->rev = false;
    swap(t->l, t->r);
    if( t->l )  t->l->rev ^= true;
    if( t->r )  t->r->rev ^= true;
  }
  //reset the value of current node assuming it now
  //represents a single element of the array
  void reset(pnode &t) {
    if(!t) return;
    t->sum = t->val;
    t->mx = t->val;
    t->mn = t->val;
  }
  //combine node l and r to form t by updating corresponding queries
  void combine(pnode &t, pnode l, pnode r) {
    if(!l) {
      t = r;
      return;
    }
    if(!r) {
      t = l;
      return;
    }
    //Beware!!!Here t can be equal to l or r anytime
    //i.e. t and (l or r) is representing same node
    //so operation is needed to be done carefully
    //e.g. if t and r are same then after t->sum=l->sum+r->sum operation,
    //r->sum will be the same as t->sum
    //so BE CAREFUL
    t->sum = l->sum + r->sum;
    t->mx = max(l->mx, r->mx);
    t->mn = min(l->mn, r->mn);
  }
  //perform all operations
  void operation(pnode &t) {
    if( !t )    return;
    reset(t);
    lazy_rev_upd(t->l);
    lazy_rev_upd(t->r);
    lazy_repl_upd(t->l);
    lazy_repl_upd(t->r);
    lazy_sum_upd(t->l);
    lazy_sum_upd(t->r);
    combine(t, t->l, t);
    combine(t, t, t->r);
  }
  //split node t in l and r by key k
  //so first k+1 elements(0,1,2,...k) of the array from node t
  //will be split in left node and rest will be in right node
  void split(pnode t, pnode &l, pnode &r, int k, int add = 0) {
    if(t == NULL) {
      l = NULL;
      r = NULL;
      return;
    }
    lazy_rev_upd(t);
    lazy_repl_upd(t);
    lazy_sum_upd(t);
    int idx = add + size(t->l);
    if(t->l) t->l->par = NULL;
    if(t->r) t->r->par = NULL; 
    if(idx <= k)
      split(t->r, t->r, r, k, idx + 1), l = t;
    else
      split(t->l, l, t->l, k, add), r = t;

    update_parent(t);
    update_size(t);
    operation(t);
  }
  //merge node l with r in t
  void merge(pnode &t, pnode l, pnode r) {
    lazy_rev_upd(l);
    lazy_rev_upd(r);
    lazy_repl_upd(l);
    lazy_repl_upd(r);
    lazy_sum_upd(l);
    lazy_sum_upd(r);
    if(!l) {
      t = r;
      return;
    }
    if(!r) {
      t = l;
      return;
    }

    if(l->prior > r->prior)
      merge(l->r, l->r, r), t = l;
    else
      merge(r->l, l, r->l), t = r;

    update_parent(t);
    update_size(t);
    operation(t);
  }
  //insert val in position a[pos]
  //so all previous values from pos to last will be right shifted
  void insert(int pos, int val) {
    if(root == NULL) {
      pnode to_add = new node(val);
      root = to_add;
      position[val] = root;
      return;
    }

    pnode l, r, mid;
    mid = new node(val);
    position[val] = mid;

    split(root, l, r, pos - 1);
    merge(l, l, mid);
    merge(root, l, r);

	/*pnode x = new Node(val),merge(root,root,x);*/
  }
  //erase from qL to qR indexes
  //so all previous indexes from qR+1 to last will be left shifted qR-qL+1 times
  void erase(int qL, int qR) {
    pnode l, r, mid;

    split(root, l, r, qL - 1);
    split(r, mid, r, qR - qL);
    merge(root, l, r);
  }
  //returns answer for corresponding types of query
  int query(int qL, int qR) {
    pnode l, r, mid;

    split(root, l, r, qL - 1);
    split(r, mid, r, qR - qL);

    int answer = mid->sum;
    merge(r, mid, r);
    merge(root, l, r);

    return answer;
  }
  //add val in all the values from a[qL] to a[qR] positions
  void update(int qL, int qR, int val) {
    pnode l, r, mid;

    split(root, l, r, qL - 1);
    split(r, mid, r, qR - qL);
    lazy_repl_upd(mid);
    mid->lazy += val;

    merge(r, mid, r);
    merge(root, l, r);
  }
  //reverse all the values from qL to qR
  void reverse(int qL, int qR) {
    pnode l, r, mid;

    split(root, l, r, qL - 1);
    split(r, mid, r, qR - qL);

    mid->rev ^= 1;
    merge(r, mid, r);
    merge(root, l, r);
  }
  //replace all the values from a[qL] to a[qR] by v
  void replace(int qL, int qR, int v) {
    pnode l, r, mid;

    split(root, l, r, qL - 1);
    split(r, mid, r, qR - qL);
    lazy_sum_upd(mid);
    mid->repl_flag = 1;
    mid->repl = v;
    merge(r, mid, r);
    merge(root, l, r);
  }
  //it will cyclic right shift the array k times
  //so for k=1, a[qL]=a[qR] and all positions from ql+1 to qR will
  //have values from previous a[qL] to a[qR-1]
  //if you make left_shift=1 then it will to the opposite
  void cyclic_shift(int qL, int qR, int k, bool left_shift = 0) {
    if(qL == qR) return;
    k %= (qR - qL + 1);

    pnode l, r, mid, fh, sh;
    split(root, l, r, qL - 1);
    split(r, mid, r, qR - qL);

    if(left_shift == 0) split(mid, fh, sh, (qR - qL + 1) - k - 1);
    else split(mid, fh, sh, k - 1);
    merge(mid, sh, fh);

    merge(r, mid, r);
    merge(root, l, r);
  }
  bool exist;
  //returns index of node curr
  int get_pos(pnode curr, pnode son = nullptr) {
    if(exist == 0) return 0;
    if(curr == NULL) {
      exist = 0;
      return 0;
    }
    if(!son) {
      if(curr == root) return size(curr->l);
      else return size(curr->l) + get_pos(curr->par, curr);
    }

    if(curr == root) {
      if(son == curr->l) return 0;
      else return size(curr->l) + 1;
    }

    if(curr->l == son) return get_pos(curr->par, curr);
    else return get_pos(curr->par, curr) + size(curr->l) + 1;
  }
  //returns index of the value
  //if the value has multiple positions then it will
  //return the last index where it was added last time
  //returns -1 if it doesn't exist in the array
  int get_pos(int value) {
    if(position.find(value) == position.end()) return -1;
    exist = 1;
    int x = get_pos(position[value]);
    if(exist == 0) return -1;
    else return x;
  }
  //returns value of index pos
  int get_val(int pos) {
    return query(pos, pos);
  }
  //returns size of the treap
  int size() {
    return size(root);
  }
  //inorder traversal to get indexes chronologically
  void inorder(pnode cur) {
    if(cur == NULL) return;
    operation(cur);
    inorder(cur->l);
    cout << cur->val << ' ';
    inorder(cur->r);
  }
  //print current array values serially
  void print_array() {
//      for(int i=0;i<size();i++) cout<<get_val(i)<<' ';
//      cout<<nl;
    inorder(root);
    cout << nl;
  }
  bool find(int val) {
    if(get_pos(val) == -1) return 0;
    else return 1;
  }
};

treap t;
//Beware!!!here treap is 0-indexed

int main() {
  int i, j, k, n, m, l, r, q;
  for(i = 0; i < 10; i++) t.insert(i, i * 10);
  t.cyclic_shift(4, 5, 1);
  t.update(2, 5, 1);
  t.replace(2, 5, 100);
  t.reverse(2, 9);
  t.replace(2, 5, 200);
  cout << t.query(0, 7) << nl;
  t.cyclic_shift(2, 3, 2, 1);
  cout << t.get_pos(20) << nl;
  t.erase(2, 2);
  cout << t.find(30) << nl;
  t.print_array();
  return 0;
}
\end{lstlisting}

% --------------------------------------------------------------------

\section{Graph Theory}

\subsection{Bipartite Check BFS}
\begin{lstlisting}[style=compactcpp]
bool bfs(int s){
    queue<int> q;
    q.push(s);
    color[s] = 1; // Assign the initial color
 
    while(!q.empty()){
        int u = q.front();
        q.pop();
 
        // Check all adjacent vertices of u
        for(auto v : adj[u]){
            // If v is not colored yet
            if(color[v] == 0){
                color[v] = (color[u] == 1) ? 2 : 1;
                q.push(v);
            }
            else if (color[v] == color[u]){
                return false;
            }
        }
    }
    return true;
}

\end{lstlisting}

\subsection{Cycle Detection DFS}

\begin{lstlisting}[style=compactcpp]
// Thanks CP-Algo for Cycle finding implementation: https://cp-algorithms.com/graph/finding-cycle.html
 
bool dfs(int v, int par) { // passing vertex and its parent vertex
    visited[v] = true;
    for (int u : adj[v]) {
        if(u == par) continue; // skipping edge to parent vertex
        if (visited[u]) {
            cycle_end = v;
            cycle_start = u;
            return true;
        }
        parent[u] = v;
        if (dfs(u, parent[u]))
            return true;
    }
    return false;
}

void find_cycle() {
    visited.assign(n+1, false);
    parent.assign(n+1, -1);
    cycle_start = -1;
 
    for (int v = 0; v < n; v++) {
        if (!visited[v] && dfs(v, parent[v]))
            break;
    }
 
    if (cycle_start == -1) {
        cout << "IMPOSSIBLE" << endl;
    } else {
        vector<int> cycle;
        cycle.push_back(cycle_start);
        for (int v = cycle_end; v != cycle_start; v = parent[v])
            cycle.push_back(v);
        cycle.push_back(cycle_start);
 
        cout << cycle.size()<<endl;;
        for (int v : cycle)
            cout << v << " ";
        cout << endl;
    }
}
\end{lstlisting}

\subsection{Cycle Detection DFS - Stack Based}

\begin{lstlisting}[style=compactcpp]
// Cycle detection using stack to track the current path (for directed graphs)
int n; // number of vertices
vector<vector<int>> adj(MAX);
stack<int> st;
vector<bool> visited(MAX);
vector<bool> stFlg(MAX);
vector<int> arns;
int depth = 0;
 
bool dfs(int v) {
    visited[v] = true;
    st.push(v);
    stFlg[v] = true;
    for(auto &z : adj[v]){
        if(!visited[z])
            if(dfs(z)) return true;
        
        if(stFlg[z]){
            st.push(z);
            return true;
        }
    }
 
    st.pop();
    stFlg[v] = false;
    return false;
}
 
void printCycle(){
    int tmp = st.top();
    while(!st.empty()){
        arns.push_back(st.top());
        st.pop();
        if(arns.back() == tmp and arns.size() != 1) break;
    }
    reverse(arns.begin(), arns.end());
 
    cout<<arns.size()<<endl;
    for(auto v: arns) cout<<v<<" ";
    cout<<endl;
}
\end{lstlisting}

\subsection{Topological Sort}

\begin{lstlisting}[style=compactcpp]
vector<int> ans;
 
void dfs(int v) {
    visited[v] = true;
    for (int u : adj[v]) {
        if (!visited[u])
            dfs(u);
    }
    ans.push_back(v);
}
 
void topological_sort() {
    visited.assign(n+1, false);
    ans.clear();
    for (int i = 1; i <= n; ++i) {
        if (!visited[i]) {
            dfs(i);
        }
    }
    reverse(ans.begin(), ans.end());
}
\end{lstlisting}

\subsection{Kahn's Algorithm}

\begin{lstlisting}[style=compactcpp]
def kahnTopoSort(self,adj: List[List[int]]) -> List[int]:
        #print(adj)
        in_deg = [0] * len(adj)
        for i in range(len(adj)):
            for u in adj[i]:
                in_deg[u]+=1
        
        q = []
        for i in range(len(in_deg)):
            if in_deg[i] == 0:
                q.append(i)

        arns = []
        while len(q)>0:
            u = q[0]
            q.pop(0)
            arns.append(u)

            for v in adj[u]:
                in_deg[v]-=1
                if in_deg[v] == 0:
                    q.append(v)

        print(str(len(arns))+" "+str(len(adj)))
        if(len(arns) != len(adj)): 
            return []

        return arns
\end{lstlisting}

\subsection{Lexicographically Min. TopoSort}

\begin{lstlisting}[style=compactcpp]
int n;
vector<vector<int>> adj(MAX);
vector<int> in_degree(MAX);
vector<int> group_ids(MAX);
vector<int> ans;

//topological sort implementation: https://cp-algorithms.com/graph/topological-sort.html

void topological_sort() {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;

    for(int i = 1; i <= n; i++) {
        if(in_degree[i] == 0) {
            pq.emplace(group_ids[i], i);
        }
    }

    while(!pq.empty()) {
        int u = pq.top().second;
        pq.pop();
        ans.push_back(u);

        for(int v : adj[u]) {
            in_degree[v]--;
            if(in_degree[v] == 0) {
                pq.emplace(group_ids[v], v);
            }
        }
    }

}
\end{lstlisting}

\subsection{BFS Flood Fill}

\begin{lstlisting}[style=compactcpp]
    bool validate(int x, int y){
	if(vis[x][y]) return false;
	if(maze[x][y] == '#') return false;
	if(x<0 or x>=n or y<0 or y>=m) return false;
	return true;
}
 
bool solveMaze(int x, int y){
    queue<pii> q;
    q.push(mp(x,y));
    vis[x][y] = true;

    int dx[] = {1, -1, 0, 0};
    int dy[] = {0, 0, 1, -1};
    char move_dir[] = {'D', 'U', 'R', 'L'};
 
	while(!q.empty()){
		int u =  q.front().fs;
		int v = q.front().sc;
		q.pop();
 
		if(maze[u][v] == 'B'){
			while(true){
				res.push_back(path[u][v]);
 
				if(res.back() == 'U' && u + 1 < n) u++;
				if(res.back() == 'D' && u - 1 >= 0) u--;
				if(res.back() == 'L' && v + 1 < m) v++;
				if(res.back() == 'R' && v - 1 >= 0) v--;
 
				if(u == x and v ==y) break;
			}
			return true;
		}
            for (int i = 0; i < 4; ++i) {
                int new_u = u + dx[i];
                int new_v = v + dy[i];
                if (validate(new_u, new_v)) {
                    path[new_u][new_v] = move_dir[i];
                    vis[new_u][new_v] = true;
                    q.push(mp(new_u, new_v));
                }
            }
        }
    return false;
}
\end{lstlisting}

\subsection{BFS Iterative Flood Fill}

\begin{lstlisting}[style=compactcpp]
void floodFill(int x, int y, char color ,int r, int c) {
	if (maze[x][y] == color) return;
	queue<pii> q;
	q.push(pii(x, y));
    while (!q.empty()) {
        pii currentCoor = q.front();
        q.pop();
        x = currentCoor.fi;
        y = currentCoor.sc;
        if (x >= 0 && x < r && y >= 0 && y < c && maze[x][y] != color) {
            maze[x][y] = color;
            q.push(pii(x + 1, y));
            q.push(pii(x - 1, y));
            q.push(pii(x, y + 1));
            q.push(pii(x, y - 1));
        }
    }
}
\end{lstlisting}

\subsection{DFS Flood Fill}

\begin{lstlisting}[style=compactcpp]
void floodFill(int x, int y, char color,vector<vector<char>>& board){
    if(x<0 or y<0 or x>=board.size() or y>=board[x].size() or board[x][y] != 'O') return;
    board[x][y] = color;
    floodFill(x+1,y,color,board);
    floodFill(x-1,y,color,board);
    floodFill(x,y+1,color,board);
    floodFill(x,y-1,color,board);
}
\end{lstlisting}

\subsection{Lava Flow (Multi-source BFS)}

\begin{lstlisting}[style=compactcpp]
    struct Cell{
    int x,y,t;
};
 
const int MAX = 1005;
int n,m;
 
char maze[MAX][MAX];
int vis[MAX][MAX];
int player[MAX][MAX];
char path[MAX][MAX];
set<pii> isExit;
queue<Cell> q;
string res;
 
bool isValid(int x, int y){
    if(x < 0 || x >= n || y < 0 || y >= m) return false;
    if(maze[x][y] == '#') return false;
    return true;
}

bool isSafe(int x, int y, int u, int v){
    return player[x][y] == -1 and maze[x][y] != 'M' and (vis[x][y] == -1 or player[u][v] + 1 < vis[x][y]);
}


void restorePath(int u, int v, int x, int y){
	 while (x != u || y != v) {
        res.push_back(path[u][v]);

        if (res.back() == 'U') u++;
        if (res.back() == 'D') u--;
        if (res.back() == 'L') v++;
        if (res.back() == 'R') v--;
    }
}
 
bool lavaFlow(int x,int y){
        q.push({x,y,1});
        player[x][y] = 0;

	while(!q.empty()){
		int u =  q.front().x;
		int v = q.front().y;
            int t = q.front().t;

		q.pop();

            vector<pii> dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
     
    	for(auto it: dir){
                int i = u+it.fs;
                int j = v+it.sc;
    
                if(isValid(i,j)){
                    if(t == 0){
                        if(vis[i][j] == -1){
                            vis[i][j] = vis[u][v]+1;
                            q.push(Cell{i,j,0});
                        }
                    }else{
                        if(isSafe(i,j,u,v)){
                            path[i][j] = (it.fs == 1) ? 'D' : (it.fs == -1) ? 'U' : (it.sc == 1) ? 'R' : 'L';
                            player[i][j] = player[u][v]+1;
                            q.push(Cell{i,j,1});
                            if (isExit.find({i,j}) != isExit.end()) {
                                if (player[i][j] < vis[i][j] || vis[i][j] == -1) {
                                    restorePath(i, j, x, y);
                                    return true;
                                }
                            }
                        }
                    }
                }
    
        }
    }
 
    return false;
}
\end{lstlisting}

\subsection{Dijkstra}

\begin{lstlisting}[style=compactcpp]
typedef pair<ll, ll> pll;
 
vector<ll> dijkstra(int n, int source, vector<vector<pll>> &adj) {
    vector<ll> dist(n, INF);
    priority_queue<pll, vector<pll>, greater<pll>> pq; 
    dist[source] = 0;
    pq.push({0, source}); 

    while (!pq.empty()) {
        ll d = pq.top().first; 
        ll u = pq.top().second; 
        pq.pop();

        if (d > dist[u]) continue;

        for (auto &edge : adj[u]) {
            ll v = edge.first;
            ll weight = edge.second; 

            if (dist[u] + weight < dist[v]) { 
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v}); 
            }
        }
    }

    return dist;
}
\end{lstlisting}

\subsection{Bellman Ford (With path restoring)}

\begin{lstlisting}[style=compactcpp]
struct Edge {
    int src, dest, weight;
};

void bellmanFord(int V, int E, vector<Edge>& edges, int start) {
    vector<int> dist(V+1, INT_MAX);
    dist[start] = 0;

    for (int i = 1; i < V; i++) {
        for (int j = 0; j < E; j++) {
            int u = edges[j].src;
            int v = edges[j].dest;
            int weight = edges[j].weight;
            if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
            }
        }
    }

    for (int j = 0; j < E; j++) {
        int u = edges[j].src;
        int v = edges[j].dest;
        int weight = edges[j].weight;
        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
            //cout << "Graph contains a negative weight cycle\n";
            return;
        }
    }

    for(int i=1; i<=V; i++){
        if(dist[i]!=INT_MAX){
            cout<<dist[i]<<" ";
        }else{
            cout<<"30000 ";
        }
    }
    cout<<endl;

}

void solve()
{
    vector<int> d(n, INF);
    d[v] = 0;
    vector<int> p(n, -1);

    for (;;) {
        bool any = false;
        for (Edge e : edges)
            if (d[e.a] < INF)
                if (d[e.b] > d[e.a] + e.cost) {
                    d[e.b] = d[e.a] + e.cost;
                    p[e.b] = e.a;
                    any = true;
                }
        if (!any)
            break;
    }

    if (d[t] == INF)
        cout << "No path from " << v << " to " << t << ".";
    else {
        vector<int> path;
        for (int cur = t; cur != -1; cur = p[cur])
            path.push_back(cur);
        reverse(path.begin(), path.end());

        cout << "Path from " << v << " to " << t << ": ";
        for (int u : path)
            cout << u << ' ';
    }
}
\end{lstlisting}

\subsection{SPFA Bellman Ford}
\begin{lstlisting}[style=compactcpp]
const int INF = 1000000000;
vector<vector<pair<int, int>>> adj;

bool spfa(int s, vector<int>& d) {
    int n = adj.size();
    d.assign(n, INF);
    vector<int> cnt(n, 0);
    vector<bool> inqueue(n, false);
    queue<int> q;

    d[s] = 0;
    q.push(s);
    inqueue[s] = true;
    while (!q.empty()) {
        int v = q.front();
        q.pop();
        inqueue[v] = false;

        for (auto edge : adj[v]) {
            int to = edge.first;
            int len = edge.second;

            if (d[v] + len < d[to]) {
                d[to] = d[v] + len;
                if (!inqueue[to]) {
                    q.push(to);
                    inqueue[to] = true;
                    cnt[to]++;
                    if (cnt[to] > n)
                        return false;  // negative cycle
                }
            }
        }
    }
    return true;
}
\end{lstlisting}

\subsection{Bellman Ford - Negative Cycle Detection}

\begin{lstlisting}[style=compactcpp]
// Bellman-Ford algorithm for detecting and finding negative cycles
struct Edge {
    int u, v;
    ll w;
};
 
void bellmanFord(int V, int E, vector<Edge>& edges, int start) {
    vector<ll> dist(V, INF);
    dist[start] = 0;
    vector<int> prev(V, -1);
 
    int x;
    for (int i = 0; i < V; i++){
        x = -1;
        for (int j = 0; j < E; j++){
            int u = edges[j].u;
            int v = edges[j].v;
            ll weight = edges[j].w;
            if (dist[u] != INF && dist[u] + weight < dist[v]) {
                dist[v] = max(-INF, (ll) dist[u] + weight);
                prev[v] = u;
                x = v;
            }
        }
    }
 
    if(x == -1){
        cout<<"NO"<<endl; // No negative Cycle
    }else{
        cout<<"YES"<<endl;
        int curr = x;
        for (int i = 0; i < V; ++i)
            curr = prev[curr];
        
        vector<int> cycle;
        for (int x = curr;; x = prev[x]) {
            cycle.push_back(x);
            if (x == curr and cycle.size() > 1) break;
        }
 
        
        reverse(cycle.begin(), cycle.end());
 
        for(int v : cycle)
            cout<<v+1<<" ";
        //cout<<cycle[0]+1<<endl;
    }
 
    
}
\end{lstlisting}

\subsection{Bellman Ford - Handling Negative Infinity}

\begin{lstlisting}[style=compactcpp]
// Bellman-Ford with proper handling of negative infinity distances
vector<ll> dist(MAX, INF);
 
struct Edge {
    int u, v;
    ll w;
};
 
void bellmanFord(int V, int E, vector<Edge>& edges, int start) {
    dist[start] = 0;
    vector<int> prev(V, -1);
 
    for (int i = 0; i < V-1; i++){
        for (int j = 0; j < E; j++){
            int u = edges[j].u;
            int v = edges[j].v;
            ll w = edges[j].w;
            if (dist[u] == INF) continue;
            dist[v] = min(dist[v], w+dist[u]);
            if (dist[v] > dist[u] + w){
                dist[v] = max(MIN_INF, dist[u] + w);
            }
        }
    }
 
    for (int i = 0; i < V-1; i++){
        for (int j = 0; j < E; j++){
            int u = edges[j].u;
            int v = edges[j].v;
            ll w = edges[j].w;
            if (dist[u] == INF) continue;
            dist[v] = max(MIN_INF,dist[v]);
            if (dist[u] == MIN_INF or dist[v] > dist[u] + w){
                dist[v] = MIN_INF;
            }
        }
    }
 
}
\end{lstlisting}

\subsection{Floyd-Warshall}

\begin{lstlisting}[style=compactcpp]
void floydWarshall(vector<vector<ll>> &d, int n){
    for (int k = 0; k < n; ++k) {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]); 
            }
        }
    }
}
\end{lstlisting}

\subsection{Prim's Algorithm (MST)}

\begin{lstlisting}[style=compactcpp]
ll prim(int V, int E, vector<vector<pll>> &adj) {
  
    priority_queue<pll, vector<pll>, greater<pll>> pq; 
    
    vector<bool> visited(V, false);
    
    ll res = 0;
    
    pq.push({0, 0});
    
    while(!pq.empty()){
        auto p = pq.top();
        pq.pop();
        
        int wt = p.first; 
        int u = p.second;
        
        if(visited[u] == true){
            continue; 
        }
        
        res += wt;
        visited[u] = true;
        
        for(auto v : adj[u]){
            if(visited[v.first] == false){
                pq.push({v.second, v.first});
            }
        }
    }

    for(int i=0; i<V; i++){
        if(!visited[i])
            return -1;
    }
    
    return res;
}
\end{lstlisting}

\subsection{Kruskal's Algorithm (MST)}

\begin{lstlisting}[style=compactcpp]
struct Edge { int u, v, weight; };

int kruskal(vector<Edge>& edges, int n) {
    sort(edges.begin(), edges.end(), 
        [](Edge& a, Edge& b) { return a.weight < b.weight; });
    
    DisjointSets dsu(n);
    int total_weight = 0;
    
    for (Edge& e : edges) {
        if (!dsu.connected(e.u, e.v)) {
            dsu.unite(e.u, e.v);
            total_weight += e.weight;
        }
    }
    return total_weight;
}
\end{lstlisting}

\subsection{Another Kruskal}

\begin{lstlisting}[style=compactcpp]
struct Edge {
    int u, v, w;
    bool operator<(Edge const& other) {
        return w < other.w;
    }
};
 
int kruskal(int n, vector<Edge> &edges, DisjointSets &dsu, vector<Edge> &ans) {
    int cost = 0;
    sort(edges.begin(), edges.end());
    for (Edge e : edges) {
        if (ans.size() == n - 1) break;
        if(dsu.unite(e.u, e.v)){
            cost += e.w;
            ans.push_back(e);
        }
    }
 
    if(ans.size()!=n-1) return -1;
    return cost;
}
\end{lstlisting}

\subsection{Kosaraju Algorithm (SCC)}

\begin{lstlisting}[style=compactcpp]
vector<bool> visited; // keeps track of which vertices are already visited

// runs depth first search starting at vertex v.
// each visited vertex is appended to the output vector when dfs leaves it.
void dfs(int v, vector<vector<int>> const& adj, vector<int> &output) {
    visited[v] = true;
    for (auto u : adj[v])
        if (!visited[u])
            dfs(u, adj, output);
    output.push_back(v);
}

// input: adj -- adjacency list of G
// output: components -- the strongy connected components in G
// output: adj_cond -- adjacency list of G^SCC (by root vertices)
void strongly_connected_components(vector<vector<int>> const& adj,
                                  vector<vector<int>> &components,
                                  vector<vector<int>> &adj_cond) {
    int n = adj.size();
    components.clear(), adj_cond.clear();

    vector<int> order; // will be a sorted list of G's vertices by exit time

    visited.assign(n, false);

    // first series of depth first searches
    for (int i = 0; i < n; i++)
        if (!visited[i])
            dfs(i, adj, order);

    // create adjacency list of G^T
    vector<vector<int>> adj_rev(n);
    for (int v = 0; v < n; v++)
        for (int u : adj[v])
            adj_rev[u].push_back(v);

    visited.assign(n, false);
    reverse(order.begin(), order.end());

    vector<int> roots(n, 0); // gives the root vertex of a vertex's SCC

    // second series of depth first searches
    for (auto v : order)
        if (!visited[v]) {
            std::vector<int> component;
            dfs(v, adj_rev, component);
            components.push_back(component);
            int root = *min_element(begin(component), end(component));
            for (auto u : component)
                roots[u] = root;
        }

    // add edges to condensation graph
    adj_cond.assign(n, {});
    for (int v = 0; v < n; v++)
        for (auto u : adj[v])
            if (roots[v] != roots[u])
                adj_cond[roots[v]].push_back(roots[u]);
}
\end{lstlisting}

\subsection{SCC}

\begin{lstlisting}[style=compactcpp]
typedef long long ll;
typedef vector<int> vec;
const ll mod=1e9+7;
const int MAX=1e5+3;
vector<vector<int>> g(MAX);
vector<vector<int>> r(MAX);
vector<int> id(MAX);
bool visitados[MAX]={false};
vector<int> l;

void dfs(int s){
    visitados[s]=true;
    for(int c:g[s]){
        if(!visitados[c]) dfs(c);
    }
    l.push_back(s);
}

void rdfs(int s,int d)
{
    visitados[s]=true;
    id[s]=d;
    for(int c:r[s])
    {
        if(!visitados[c]) rdfs(c,d);
    }
}
\end{lstlisting}

\subsection{SCC - Kosaraju Simple Implementation}

\begin{lstlisting}[style=compactcpp]
// Simple Kosaraju's algorithm for finding strongly connected components
vector<vector<int>> adj(MAX);
vector<vector<int>> t_adj(MAX);
vector<int> v_id(MAX);
bool visited[MAX];
vector<int> order; // Append the respective nodes with dfsA order
 
// Calculate vertex order
void dfsA(int s){
    visited[s] = true;
    for(int u : adj[s]){
        if(!visited[u])
            dfsA(u);
    }
    order.push_back(s);
}
 
// Set its component id to every vertex
void dfsB(int s, int c){
    visited[s] = true;
    for(int u: t_adj[s]){
        if(!visited[u])
            dfsB(u,c);
    }
    v_id[s] = c;
}
\end{lstlisting}

\subsection{Tarjan algorithm (SCC)}

\begin{lstlisting}[style=compactcpp]
/** Takes in an adjacency list and calculates the SCCs of the graph. */
class TarjanSolver {
  private:
	vector<vector<int>> rev_adj;
	vector<int> post;
	vector<int> comp;

	vector<bool> visited;
	int timer = 0;
	int id = 0;

	void fill_post(int at) {
		visited[at] = true;
		for (int n : rev_adj[at]) {
			if (!visited[n]) { fill_post(n); }
		}
		post[at] = timer++;
	}

	void find_comp(int at) {
		visited[at] = true;
		comp[at] = id;
		for (int n : adj[at]) {
			if (!visited[n]) { find_comp(n); }
		}
	}

  public:
	const vector<vector<int>> &adj;

	TarjanSolver(const vector<vector<int>> &adj)
	    : adj(adj), rev_adj(adj.size()), post(adj.size()), comp(adj.size()),
	      visited(adj.size()) {
		vector<int> nodes(adj.size());
		for (int n = 0; n < adj.size(); n++) {
			nodes[n] = n;
			for (int next : adj[n]) { rev_adj[next].push_back(n); }
		}

		for (int n = 0; n < adj.size(); n++) {
			if (!visited[n]) { fill_post(n); }
		}
		std::sort(nodes.begin(), nodes.end(),
		          [&](int n1, int n2) { return post[n1] > post[n2]; });

		visited.assign(adj.size(), false);
		for (int n : nodes) {
			if (!visited[n]) {
				find_comp(n);
				id++;
			}
		}
	}

	int comp_num() const { return id; }

	int get_comp(int n) const { return comp[n]; }
};
\end{lstlisting}

\subsection{Finding Articulation Points}

\begin{lstlisting}[style=compactcpp]
// adj[u] = adjacent nodes of u
// ap = AP = articulation points
// p = parent
// disc[u] = discovery time of u
// low[u] = 'low' node of u

int dfsAP(int u, int p) {
  int children = 0;
  low[u] = disc[u] = ++Time;
  for (int& v : adj[u]) {
    if (v == p) continue; // we don't want to go back through the same path.
                          // if we go back is because we found another way back
    if (!disc[v]) { // if V has not been discovered before
      children++;
      dfsAP(v, u); // recursive DFS call
      if (disc[u] <= low[v]) // condition #1
        ap[u] = 1;
      low[u] = min(low[u], low[v]); // low[v] might be an ancestor of u
    } else // if v was already discovered means that we found an ancestor
      low[u] = min(low[u], disc[v]); // finds the ancestor with the least discovery time
  }
  return children;
}

void AP() {
  ap = low = disc = vector<int>(adj.size());
  Time = 0;
  for (int u = 0; u < adj.size(); u++)
    if (!disc[u])
      ap[u] = dfsAP(u, u) > 1; // condition #2
}
\end{lstlisting}

\subsection{Finding bridges}

\begin{lstlisting}[style=compactcpp]
// br = bridges, p = parent

vector<pair<int, int>> br;

int dfsBR(int u, int p) {
  low[u] = disc[u] = ++Time;
  for (int& v : adj[u]) {
    if (v == p) continue; // we don't want to go back through the same path.
                          // if we go back is because we found another way back
    if (!disc[v]) { // if V has not been discovered before
      dfsBR(v, u);  // recursive DFS call
      if (disc[u] < low[v]) // condition to find a bridge
        br.push_back({u, v});
      low[u] = min(low[u], low[v]); // low[v] might be an ancestor of u
    } else // if v was already discovered means that we found an ancestor
      low[u] = min(low[u], disc[v]); // finds the ancestor with the least discovery time
  }
}

void BR() {
  low = disc = vector<int>(adj.size());
  Time = 0;
  for (int u = 0; u < adj.size(); u++)
    if (!disc[u])
      dfsBR(u, u)
}
\end{lstlisting}

\subsection{Finding Bridges Online}

\begin{lstlisting}[style=compactcpp]
vector<int> par, dsu_2ecc, dsu_cc, dsu_cc_size;
int bridges;
int lca_iteration;
vector<int> last_visit;

void init(int n) {
    par.resize(n);
    dsu_2ecc.resize(n);
    dsu_cc.resize(n);
    dsu_cc_size.resize(n);
    lca_iteration = 0;
    last_visit.assign(n, 0);
    for (int i=0; i<n; ++i) {
        dsu_2ecc[i] = i;
        dsu_cc[i] = i;
        dsu_cc_size[i] = 1;
        par[i] = -1;
    }
    bridges = 0;
}

int find_2ecc(int v) {
    if (v == -1)
        return -1;
    return dsu_2ecc[v] == v ? v : dsu_2ecc[v] = find_2ecc(dsu_2ecc[v]);
}

int find_cc(int v) {
    v = find_2ecc(v);
    return dsu_cc[v] == v ? v : dsu_cc[v] = find_cc(dsu_cc[v]);
}

void make_root(int v) {
    int root = v;
    int child = -1;
    while (v != -1) {
        int p = find_2ecc(par[v]);
        par[v] = child;
        dsu_cc[v] = root;
        child = v;
        v = p;
    }
    dsu_cc_size[root] = dsu_cc_size[child];
}

void merge_path (int a, int b) {
    ++lca_iteration;
    vector<int> path_a, path_b;
    int lca = -1;
    while (lca == -1) {
        if (a != -1) {
            a = find_2ecc(a);
            path_a.push_back(a);
            if (last_visit[a] == lca_iteration){
                lca = a;
                break;
                }
            last_visit[a] = lca_iteration;
            a = par[a];
        }
        if (b != -1) {
            b = find_2ecc(b);
            path_b.push_back(b);
            if (last_visit[b] == lca_iteration){
                lca = b;
                break;
                }
            last_visit[b] = lca_iteration;
            b = par[b];
        }

    }

    for (int v : path_a) {
        dsu_2ecc[v] = lca;
        if (v == lca)
            break;
        --bridges;
    }
    for (int v : path_b) {
        dsu_2ecc[v] = lca;
        if (v == lca)
            break;
        --bridges;
    }
}

void add_edge(int a, int b) {
    a = find_2ecc(a);
    b = find_2ecc(b);
    if (a == b)
        return;

    int ca = find_cc(a);
    int cb = find_cc(b);

    if (ca != cb) {
        ++bridges;
        if (dsu_cc_size[ca] > dsu_cc_size[cb]) {
            swap(a, b);
            swap(ca, cb);
        }
        make_root(a);
        par[a] = dsu_cc[a] = b;
        dsu_cc_size[cb] += dsu_cc_size[a];
    } else {
        merge_path(a, b);
    }
}
\end{lstlisting}

\subsection{Bridge Tree}

\begin{lstlisting}[style=compactcpp]
vector<pair<int, int>> g[MAXN];
bool used[MAXN], isBridge[MAXM];
int comp[MAXN], tin[MAXN], minAncestor[MAXN];

vector<int> tree[MAXN]; // Store 2-edge-connected component tree.(Bridge tree).

void dfs(int v, int p) {
    tin[v] = minAncestor[v] = ++timer;
    used[v] = 1;
    for(auto &e: g[v]) {
        int to, id;
        tie(to, id) = e;
        if(to == p) continue;
        if(used[to]) {
            minAncestor[v] = min(minAncestor[v], tin[to]);
        } else {
            dfs(to, v);
            minAncestor[v] = min(minAncestor[v], minAncestor[to]);
            if(minAncestor[to] > tin[v]) {
                isBridge[id] = true;
            }
        }
    }
}

void dfs1(int v, int p) {
    used[v] = 1;
    comp[v] = compid;
    for(auto &e: g[v]) {
        int to, id;
        tie(to, id) = e;
        
        if(isBridge[id]) { // avoid traversing from this edge. so we get full component.
            continue;
        }
        if(used[to]) {
            continue;
        }
        dfs1(to, v);
    }
}

vector<pair<int, int>> edges;

void addEdge(int from, int to, int id) {
    g[from].push_back({to, id});
    g[to].push_back({from, id});
    edges[id] = {from, to};
}

void initB() {

    for(int i = 0; i <= compid; ++i)
        tree[i].clear();
    for(int i = 1; i <= N; ++i)
        used[i] = false;
    for(int i = 1; i <= M; ++i)
        isBridge[i] = false;
    
    timer = 0;
    compid = 0;
}

void bridge_tree() {

    initB();
    
    dfs(1, -1); //Assuming graph is connected.
    
    for(int i = 1; i <= N; ++i)
        used[i] = 0;

    for(int i = 1; i <= N; ++i) {
        if(!used[i]) {
            dfs1(i, -1);
            ++compid;
        }
    }

    for(int i = 1; i <= M; ++i) {
        if(isBridge[i]) {
            int u, v;
            tie(u, v) = edges[i];
            // connect two componets using edge.
            tree[comp[u]].push_back(comp[v]);
            tree[comp[v]].push_back(comp[u]);
        }
    }
}

void init() {
    edges.clear(); edges.resize(M + 1);
    for(int i = 1; i <= N; ++i)
        g[i].clear();
}
\end{lstlisting}


\subsection{2-SAT}

\begin{lstlisting}[style=compactcpp]
struct TwoSatSolver {
    int n_vars;
    int n_vertices;
    vector<vector<int>> adj, adj_t;
    vector<bool> used;
    vector<int> order, comp;
    vector<bool> assignment;

    TwoSatSolver(int _n_vars) : n_vars(_n_vars), n_vertices(2 * n_vars), adj(n_vertices), adj_t(n_vertices), used(n_vertices), order(), comp(n_vertices, -1), assignment(n_vars) {
        order.reserve(n_vertices);
    }
    void dfs1(int v) {
        used[v] = true;
        for (int u : adj[v]) {
            if (!used[u])
                dfs1(u);
        }
        order.push_back(v);
    }

    void dfs2(int v, int cl) {
        comp[v] = cl;
        for (int u : adj_t[v]) {
            if (comp[u] == -1)
                dfs2(u, cl);
        }
    }

    bool solve_2SAT() {
        order.clear();
        used.assign(n_vertices, false);
        for (int i = 0; i < n_vertices; ++i) {
            if (!used[i])
                dfs1(i);
        }

        comp.assign(n_vertices, -1);
        for (int i = 0, j = 0; i < n_vertices; ++i) {
            int v = order[n_vertices - i - 1];
            if (comp[v] == -1)
                dfs2(v, j++);
        }

        assignment.assign(n_vars, false);
        for (int i = 0; i < n_vertices; i += 2) {
            if (comp[i] == comp[i + 1])
                return false;
            assignment[i / 2] = comp[i] > comp[i + 1];
        }
        return true;
    }

    void add_disjunction(int a, bool na, int b, bool nb) {
        // na and nb signify whether a and b are to be negated 
        a = 2 * a ^ na;
        b = 2 * b ^ nb;
        int neg_a = a ^ 1;
        int neg_b = b ^ 1;
        adj[neg_a].push_back(b);
        adj[neg_b].push_back(a);
        adj_t[b].push_back(neg_a);
        adj_t[a].push_back(neg_b);
    }

    static void example_usage() {
        TwoSatSolver solver(3); // a, b, c
        solver.add_disjunction(0, false, 1, true);  //     a  v  not b
        solver.add_disjunction(0, true, 1, true);   // not a  v  not b
        solver.add_disjunction(1, false, 2, false); //     b  v      c
        solver.add_disjunction(0, false, 0, false); //     a  v      a
        assert(solver.solve_2SAT() == true);
        auto expected = vector<bool>(True, False, True);
        assert(solver.assignment == expected);
    }
};
\end{lstlisting}

\subsection{Hierholzer's Algorithm (Eulerian Path)}

\begin{lstlisting}[style=compactcpp]
int n, m;
vector<vector<int>> g;
vector<int> in, out, path;

// Undirected

int n, m;
vector<vector<pair<int, int>>> g;
vector<int> path;
vector<bool> seen;

void dfs(int node) {
	while (!g[node].empty()) {
		auto [son, idx] = g[node].back();
		g[node].pop_back();
		if (seen[idx]) { continue; }
		seen[idx] = true;
		dfs(son);
	}
	path.push_back(node);
}

// Directed
void dfs(int node) {
	while (!g[node].empty()) {
		int son = g[node].back();
		g[node].pop_back();
		dfs(son);
	}
	path.push_back(node);
}

\end{lstlisting}

\subsection{Gale-Shapley Algorithm (Stable marriage)}

\begin{lstlisting}[style=compactcpp]
// Checks if woman 'w' prefers 'm1' over 'm'
bool wPrefersM1OverM(vector<vector<int>> &prefer, int w, int m, int m1)
{
    int N = prefer[0].size();
    for (int i = 0; i < N; i++)
    {
        // If m1 comes before m, w prefers
        // her current engagement
        if (prefer[w][i] == m1)
            return true;

        // If m comes before m1, w prefers m
        if (prefer[w][i] == m)
            return false;
    }
}

// Implements the stable marriage algorithm
vector<int> stableMarriage(vector<vector<int>> &prefer)
{
    int N = prefer[0].size();

    // Stores women's partners
    vector<int> wPartner(N, -1);

    // Tracks free men
    vector<bool> mFree(N, false);
    int freeCount = N;

    while (freeCount > 0)
    {
        int m;
        for (m = 0; m < N; m++)
            if (!mFree[m])
                break;

        // Process each woman in m's preference list
        for (int i = 0; i < N && !mFree[m]; i++)
        {
            int w = prefer[m][i];
            if (wPartner[w - N] == -1)
            {
                // Engage m and w if w is free
                wPartner[w - N] = m;
                mFree[m] = true;
                freeCount--;
            }
            else
            {
                int m1 = wPartner[w - N];
                // If w prefers m over her current partner, reassign
                if (!wPrefersM1OverM(prefer, w, m, m1))
                {
                    wPartner[w - N] = m;
                    mFree[m] = true;
                    mFree[m1] = false;
                }
            }
        }
    }
    return wPartner;
}
\end{lstlisting}

\section{Trees}

\subsection{Succesor}

\begin{lstlisting}[style=compactcpp]
const ll mod=1e9+7;
const ll MAX=1e9+1;
const int limit=2e5+1;
const int m=30;
int succesorM[limit][m];
//ascii https://elcodigoascii.com.ar/

inline void solve()
{
    int n,q; cin>>n>>q;
    int res,aux;
    ll k;
    lFOR(i,n){
        cin>>succesorM[i][0];
    }
    FOR(j,1,m)
    {
        lFOR(i,n)
        {
            succesorM[i][j]=succesorM[succesorM[i][j-1]][j-1];
        }
    }
    FO(i,q)
    {
        cin>>res>>k;
        aux=0;
        while(k)
        {
            if(k%2){
                res=succesorM[res][aux];
            }
            k/=2;
            aux++;
        }
        cout<<res<<endl;
    }
}
\end{lstlisting}

\subsection{Euler Tour}

\begin{lstlisting}[style=compactcpp]
const int MAXN = 1e5 + 5;

vector<int> adj[MAXN];
int in_time[MAXN], out_time[MAXN];
int timer = 0;

struct FenwickTree {
    vector<int> bit;
    int n;

    FenwickTree(int n) {
        this->n = n;
        bit.assign(n + 1, 0);
    }

    void update(int idx, int delta) {
        for (; idx <= n; idx += idx & -idx)
            bit[idx] += delta;
    }

    int query(int idx) {
        int sum = 0;
        for (; idx > 0; idx -= idx & -idx)
            sum += bit[idx];
        return sum;
    }

    int range_query(int l, int r) {
        return query(r) - query(l - 1);
    }
};

void euler_tour(int root) {
    stack<tuple<int, int, bool>> st;
    st.push({root, -1, false});

    while (!st.empty()) {
        auto [u, parent, visited] = st.top();
        st.pop();

        if (!visited) {
            in_time[u] = ++timer;
            st.push({u, parent, true});

            for (auto it = adj[u].rbegin(); it != adj[u].rend(); ++it) {
                if (*it != parent) {
                    st.push({*it, u, false});
                }
            }
        } else {
            out_time[u] = ++timer;
        }
    }
}

\end{lstlisting}

\subsection{Lowest Common Ancestor}

\begin{lstlisting}[style=compactcpp]
struct LCA {
    vector<int> height, euler, first, segtree;
    vector<bool> visited;
    int n;

    LCA(vector<vector<int>> &adj, int root = 0) {
        n = adj.size();
        height.resize(n);
        first.resize(n);
        euler.reserve(n * 2);
        visited.assign(n, false);
        dfs(adj, root);
        int m = euler.size();
        segtree.resize(m * 4);
        build(1, 0, m - 1);
    }

    void dfs(vector<vector<int>> &adj, int node, int h = 0) {
        visited[node] = true;
        height[node] = h;
        first[node] = euler.size();
        euler.push_back(node);
        for (auto to : adj[node]) {
            if (!visited[to]) {
                dfs(adj, to, h + 1);
                euler.push_back(node);
            }
        }
    }

    void build(int node, int b, int e) {
        if (b == e) {
            segtree[node] = euler[b];
        } else {
            int mid = (b + e) / 2;
            build(node << 1, b, mid);
            build(node << 1 | 1, mid + 1, e);
            int l = segtree[node << 1], r = segtree[node << 1 | 1];
            segtree[node] = (height[l] < height[r]) ? l : r;
        }
    }

    int query(int node, int b, int e, int L, int R) {
        if (b > R || e < L)
            return -1;
        if (b >= L && e <= R)
            return segtree[node];
        int mid = (b + e) >> 1;

        int left = query(node << 1, b, mid, L, R);
        int right = query(node << 1 | 1, mid + 1, e, L, R);
        if (left == -1) return right;
        if (right == -1) return left;
        return height[left] < height[right] ? left : right;
    }

    int lca(int u, int v) {
        int left = first[u], right = first[v];
        if (left > right)
            swap(left, right);
        return query(1, 0, euler.size() - 1, left, right);
    }
};
\end{lstlisting}

\subsection{Binary Lifting}

\begin{lstlisting}[style=compactcpp]
int n, l;
vector<vector<int>> adj;

int timer;
vector<int> tin, tout;
vector<vector<int>> up;

void dfs(int v, int p)
{
    tin[v] = ++timer;
    up[v][0] = p;
    for (int i = 1; i <= l; ++i)
        up[v][i] = up[up[v][i-1]][i-1];

    for (int u : adj[v]) {
        if (u != p)
            dfs(u, v);
    }

    tout[v] = ++timer;
}

bool is_ancestor(int u, int v)
{
    return tin[u] <= tin[v] && tout[u] >= tout[v];
}

int lca(int u, int v)
{
    if (is_ancestor(u, v))
        return u;
    if (is_ancestor(v, u))
        return v;
    for (int i = l; i >= 0; --i) {
        if (!is_ancestor(up[u][i], v))
            u = up[u][i];
    }
    return up[u][0];
}

void preprocess(int root) {
    tin.resize(n);
    tout.resize(n);
    timer = 0;
    l = ceil(log2(n));
    up.assign(n, vector<int>(l + 1));
    dfs(root, root);
}
\end{lstlisting}

\subsection{Cartesian Tree}

\begin{lstlisting}[style=compactcpp]
vector<int> parent(n, -1);
stack<int> s;
for (int i = 0; i < n; i++) {
    int last = -1;
    while (!s.empty() && A[s.top()] >= A[i]) {
        last = s.top();
        s.pop();
    }
    if (!s.empty())
        parent[i] = s.top();
    if (last >= 0)
        parent[last] = i;
    s.push(i);
}
\end{lstlisting}

\subsection{Heavy-Light Decomposition}

\begin{lstlisting}[style=compactcpp]
vector<int> parent, depth, heavy, head, pos;
int cur_pos;

int dfs(int v, vector<vector<int>> const& adj) {
    int size = 1;
    int max_c_size = 0;
    for (int c : adj[v]) {
        if (c != parent[v]) {
            parent[c] = v, depth[c] = depth[v] + 1;
            int c_size = dfs(c, adj);
            size += c_size;
            if (c_size > max_c_size)
                max_c_size = c_size, heavy[v] = c;
        }
    }
    return size;
}

void decompose(int v, int h, vector<vector<int>> const& adj) {
    head[v] = h, pos[v] = cur_pos++;
    if (heavy[v] != -1)
        decompose(heavy[v], h, adj);
    for (int c : adj[v]) {
        if (c != parent[v] && c != heavy[v])
            decompose(c, c, adj);
    }
}

void init(vector<vector<int>> const& adj) {
    int n = adj.size();
    parent = vector<int>(n);
    depth = vector<int>(n);
    heavy = vector<int>(n, -1);
    head = vector<int>(n);
    pos = vector<int>(n);
    cur_pos = 0;

    dfs(0, adj);
    decompose(0, 0, adj);
}

int query(int a, int b) {
    int res = 0;
    for (; head[a] != head[b]; b = parent[head[b]]) {
        if (depth[head[a]] > depth[head[b]])
            swap(a, b);
        int cur_heavy_path_max = segment_tree_query(pos[head[b]], pos[b]);
        res = max(res, cur_heavy_path_max);
    }
    if (depth[a] > depth[b])
        swap(a, b);
    int last_heavy_path_max = segment_tree_query(pos[a], pos[b]);
    res = max(res, last_heavy_path_max);
    return res;
}
\end{lstlisting}

\subsection{Centroid Decomposition}

\begin{lstlisting}[style=compactcpp]
	vector<vector<int>> adj;
vector<bool> is_removed;
vector<int> subtree_size;

/** DFS to calculate the size of the subtree rooted at `node` */
int get_subtree_size(int node, int parent = -1) {
	subtree_size[node] = 1;
	for (int child : adj[node]) {
		if (child == parent || is_removed[child]) { continue; }
		subtree_size[node] += get_subtree_size(child, node);
	}
	return subtree_size[node];
}

/**
 * Returns a centroid (a tree may have two centroids) of the subtree
 * containing node `node` after node removals
 * @param node current node
 * @param tree_size size of current subtree after node removals
 * @param parent parent of u
 * @return first centroid found
 */
int get_centroid(int node, int tree_size, int parent = -1) {
	for (int child : adj[node]) {
		if (child == parent || is_removed[child]) { continue; }
		if (subtree_size[child] * 2 > tree_size) {
			return get_centroid(child, tree_size, node);
		}
	}
	return node;
}

/** Build up the centroid decomposition recursively */
void build_centroid_decomp(int node = 0) {
	int centroid = get_centroid(node, get_subtree_size(node));

	// do something

	is_removed[centroid] = true;

	for (int child : adj[centroid]) {
		if (is_removed[child]) { continue; }
		build_centroid_decomp(child);
	}
}

\end{lstlisting}

\subsection{Tree Distances}

\begin{lstlisting}[style=compactcpp]
	
vector<int> graph[200001];
int fir[200001], sec[200001], ans[200001];

void dfs1(int node = 1, int parent = 0) {
	for (int i : graph[node])
		if (i != parent) {
			dfs1(i, node);
			if (fir[i] + 1 > fir[node]) {
				sec[node] = fir[node];
				fir[node] = fir[i] + 1;
			} else if (fir[i] + 1 > sec[node]) {
				sec[node] = fir[i] + 1;
			}
		}
}

void dfs2(int node = 1, int parent = 0, int to_p = 0) {
	ans[node] = max(to_p, fir[node]);
	for (int i : graph[node])
		if (i != parent) {
			if (fir[i] + 1 == fir[node]) dfs2(i, node, max(to_p, sec[node]) + 1);
			else dfs2(i, node, ans[node] + 1);
		}
}
\end{lstlisting}

\subsection{Tree Distances (All Longest Paths - Rerooting)}

\begin{lstlisting}[style=compactcpp]
// Tree rerooting DP to find maximum distance from each node to any other node
// f(x) = max distance from x to any node in its subtree
// g(x) = max distance from x to any node outside its subtree
// ans(x) = max(f(x), g(x)) = longest path starting from x
vector<vector<int>> adj(MAX);
vector<int> f(MAX,0); // f(x) = maximum distance from node x to any node of its subtree
vector<int> g(MAX,0); // g(x) = maximum distance from any node to x  outside its subtree
vector<int> arns(MAX,0); // arns(x) = max(f(x),g(x))
 
 
void dfsA(int s, int e){
    for(auto u : adj[s]){
        if(u == e) continue;
        dfsA(u,s);
        if(f[u]+1 > f[s]){ // Maximum distance + 1 of u > Max dist of predecessor
            g[s] = f[s];   // Maximum distance from any node outside of s subtree is f[s] 
            f[s] = f[u] + 1;
        }else if(f[u]+1>g[s]){
            g[s] = f[u]+1; // Maximum distance from any node outside of s subtree is f[u]+1
        }
    }
}
 
void dfsB(int s, int e, int to){
    arns[s] = max(to, f[s]);
    for(auto u : adj[s]){
        if(u == e) continue;
        if(f[u]+1 == f[s]) dfsB(u,s, max(to,g[s])+1);
        else dfsB(u,s, arns[s]+1);
    }
}
\end{lstlisting}

\subsection{Tree Hashing}

\begin{lstlisting}[style=compactcpp]
// Tree hashing using logarithmic combination for tree isomorphism
vector<ld> h_map;
vector<ld> t2_map;
vector<int> d; 
vector<vector<int>> tree;
vector<vector<int>> tree2;
int arns = 0;
 
ld hash_tree1(int u, int prev){
    vector<ld> hashes;
    for(int v : tree[u]){
        if(v == prev) continue;
        d[v] = d[u] + 1;
        hashes.push_back(hash_tree1(v,u));
    }
 
    if(hashes.empty()){
        h_map[u] = 42.0;
        return 42.0;
    }
        
    sort(hashes.begin(),hashes.end());
    
    ld hash_zum = 0.0;
    for(ld h : hashes){
        hash_zum += log2l(h);
    }
 
    ld def = 42.0 + hash_zum;
    h_map[u] = def;
    return def;
}
\end{lstlisting}

\section{Flows}

\subsection{Ford-Fulkerson Maximum Flow}

\begin{lstlisting}[style=compactcpp]
int n;
vector<vector<int>> capacity;
vector<vector<int>> adj;

int bfs(int s, int t, vector<int>& parent) {
    fill(parent.begin(), parent.end(), -1);
    parent[s] = -2;
    queue<pair<int, int>> q;
    q.push({s, INF});

    while (!q.empty()) {
        int cur = q.front().first;
        int flow = q.front().second;
        q.pop();

        for (int next : adj[cur]) {
            if (parent[next] == -1 && capacity[cur][next]) {
                parent[next] = cur;
                int new_flow = min(flow, capacity[cur][next]);
                if (next == t)
                    return new_flow;
                q.push({next, new_flow});
            }
        }
    }

    return 0;
}

int maxflow(int s, int t) {
    int flow = 0;
    vector<int> parent(n);
    int new_flow;

    while (new_flow = bfs(s, t, parent)) {
        flow += new_flow;
        int cur = t;
        while (cur != s) {
            int prev = parent[cur];
            capacity[prev][cur] -= new_flow;
            capacity[cur][prev] += new_flow;
            cur = prev;
        }
    }

    return flow;
}
\end{lstlisting}

\subsection{Dinic's Max Flow}

\begin{lstlisting}[style=compactcpp]
struct FlowEdge {
    int v, u;
    long long cap, flow = 0;
    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}
};

struct Dinic {
    const long long flow_inf = 1e18;
    vector<FlowEdge> edges;
    vector<vector<int>> adj;
    int n, m = 0;
    int s, t;
    vector<int> level, ptr;
    queue<int> q;

    Dinic(int n, int s, int t) : n(n), s(s), t(t) {
        adj.resize(n);
        level.resize(n);
        ptr.resize(n);
    }

    void add_edge(int v, int u, long long cap) {
        edges.emplace_back(v, u, cap);
        edges.emplace_back(u, v, 0);
        adj[v].push_back(m);
        adj[u].push_back(m + 1);
        m += 2;
    }

    bool bfs() {
        while (!q.empty()) {
            int v = q.front();
            q.pop();
            for (int id : adj[v]) {
                if (edges[id].cap == edges[id].flow)
                    continue;
                if (level[edges[id].u] != -1)
                    continue;
                level[edges[id].u] = level[v] + 1;
                q.push(edges[id].u);
            }
        }
        return level[t] != -1;
    }

    long long dfs(int v, long long pushed) {
        if (pushed == 0)
            return 0;
        if (v == t)
            return pushed;
        for (int& cid = ptr[v]; cid < (int)adj[v].size(); cid++) {
            int id = adj[v][cid];
            int u = edges[id].u;
            if (level[v] + 1 != level[u])
                continue;
            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));
            if (tr == 0)
                continue;
            edges[id].flow += tr;
            edges[id ^ 1].flow -= tr;
            return tr;
        }
        return 0;
    }

    long long flow() {
        long long f = 0;
        while (true) {
            fill(level.begin(), level.end(), -1);
            level[s] = 0;
            q.push(s);
            if (!bfs())
                break;
            fill(ptr.begin(), ptr.end(), 0);
            while (long long pushed = dfs(s, flow_inf)) {
                f += pushed;
            }
        }
        return f;
    }
};
\end{lstlisting}

\subsection{Min-cost Flow}

\begin{lstlisting}[style=compactcpp]
struct Edge
{
    int from, to, capacity, cost;
};

vector<vector<int>> adj, cost, capacity;

const int INF = 1e9;

void shortest_paths(int n, int v0, vector<int>& d, vector<int>& p) {
    d.assign(n, INF);
    d[v0] = 0;
    vector<bool> inq(n, false);
    queue<int> q;
    q.push(v0);
    p.assign(n, -1);

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inq[u] = false;
        for (int v : adj[u]) {
            if (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {
                d[v] = d[u] + cost[u][v];
                p[v] = u;
                if (!inq[v]) {
                    inq[v] = true;
                    q.push(v);
                }
            }
        }
    }
}

int min_cost_flow(int N, vector<Edge> edges, int K, int s, int t) {
    adj.assign(N, vector<int>());
    cost.assign(N, vector<int>(N, 0));
    capacity.assign(N, vector<int>(N, 0));
    for (Edge e : edges) {
        adj[e.from].push_back(e.to);
        adj[e.to].push_back(e.from);
        cost[e.from][e.to] = e.cost;
        cost[e.to][e.from] = -e.cost;
        capacity[e.from][e.to] = e.capacity;
    }

    int flow = 0;
    int cost = 0;
    vector<int> d, p;
    while (flow < K) {
        shortest_paths(N, s, d, p);
        if (d[t] == INF)
            break;

        // find max flow on that path
        int f = K - flow;
        int cur = t;
        while (cur != s) {
            f = min(f, capacity[p[cur]][cur]);
            cur = p[cur];
        }

        // apply flow
        flow += f;
        cost += f * d[t];
        cur = t;
        while (cur != s) {
            capacity[p[cur]][cur] -= f;
            capacity[cur][p[cur]] += f;
            cur = p[cur];
        }
    }

    if (flow < K)
        return -1;
    else
        return cost;
}
\end{lstlisting}

\subsection{Hungarian Algorithm}

\begin{lstlisting}[style=compactcpp]
vector<int> u (n+1), v (m+1), p (m+1), way (m+1);
for (int i=1; i<=n; ++i) {
    p[0] = i;
    int j0 = 0;
    vector<int> minv (m+1, INF);
    vector<bool> used (m+1, false);
    do {
        used[j0] = true;
        int i0 = p[j0],  delta = INF,  j1;
        for (int j=1; j<=m; ++j)
            if (!used[j]) {
                int cur = A[i0][j]-u[i0]-v[j];
                if (cur < minv[j])
                    minv[j] = cur,  way[j] = j0;
                if (minv[j] < delta)
                    delta = minv[j],  j1 = j;
            }
        for (int j=0; j<=m; ++j)
            if (used[j])
                u[p[j]] += delta,  v[j] -= delta;
            else
                minv[j] -= delta;
        j0 = j1;
    } while (p[j0] != 0);
    do {
        int j1 = way[j0];
        p[j0] = p[j1];
        j0 = j1;
    } while (j0);
}

vector<int> ans (n+1);
for (int j=1; j<=m; ++j)
    ans[p[j]] = j;

int cost = -v[0];
\end{lstlisting}

\subsection{Kuhn's Algorithm}

\begin{lstlisting}[style=compactcpp]
int n, k;
vector<vector<int>> g;
vector<int> mt;
vector<bool> used;

bool try_kuhn(int v) {
    if (used[v])
        return false;
    used[v] = true;
    for (int to : g[v]) {
        if (mt[to] == -1 || try_kuhn(mt[to])) {
            mt[to] = v;
            return true;
        }
    }
    return false;
}

int main() {
    //... reading the graph ...

    mt.assign(k, -1);
    for (int v = 0; v < n; ++v) {
        used.assign(n, false);
        try_kuhn(v);
    }

    for (int i = 0; i < k; ++i)
        if (mt[i] != -1)
            printf("%d %d\n", mt[i] + 1, i + 1);
}
\end{lstlisting}

\section{Dynamic Programming}

\subsection{Coin Problem (Count ways)}

\begin{lstlisting}[style=compactcpp]
vector<ll> coins(n);
for(int i=0; i<n; i++){
    cin>>coins[i];
}
    
vector<ll> dp(x+1,0);
dp[0] = 1;
for(int i=0; i<=x; i++){
    for(int j=0; j<n; j++){
        if(i-coins[j]>=0){
            dp[i] = (dp[i] + dp[i-coins[j]]);
            dp[i]%=MOD;
        }
    }
}
        
        
cout<<dp[x]<<endl;
\end{lstlisting}

\subsection{Coin Problem (Count sorted ways)}

\begin{lstlisting}[style=compactcpp]
// Count ways to make sum x using ordered coin combinations (avoids counting permutations)
void CoinDPSorted(){
    int n, x; cin>>n>>x;
    vector<ll> coins(n);
    for(int i=0; i<n; i++){
        cin>>coins[i];
    }
    
    int dp[102][1000005];
    dp[0][0] = 1;
    for(int i=1; i<=n; i++){
        for(int j=0; j<=x; j++){
            dp[i][j] = dp[i-1][j];
            int l = j-coins[i-1];
            if(l>=0){
                dp[i][j] += (dp[i][l])%MOD;
                dp[i][j]%=MOD;
            }
        }
    }

    cout<<dp[n][x]%MOD<<endl;
}
\end{lstlisting}

\subsection{Coin Problem (Minimum)}

\begin{lstlisting}[style=compactcpp]
vector<ll> coins(n);
for(int i=0; i<n; i++){
    cin>>coins[i];
}
    
vector<ll> dp(x+1,INT_MAX);
dp[0] = 0;
for(int i=0; i<=x; i++){
    for(int j=0; j<n; j++){
        if(i-coins[j]>=0){
            dp[i] = min(dp[i], dp[i-coins[j]]+1);
        }
    }
}
    
if(dp[x] != INT_MAX){
    cout<<dp[x]<<endl;
}else{
    cout<<"-1"<<endl;
}
\end{lstlisting}

\subsection{Counting paths}

\begin{lstlisting}[style=compactcpp]
int n; cin>>n;
char grid[n][n];
int dp[n][n];
    
for(int i=0; i<n; i++){
    for(int j=0; j<n; j++){
        cin>>grid[i][j];
        dp[i][j] = 0;
    }
}
if(grid[0][0] != '*')dp[0][0] = 1;
else dp[0][0] = 0;
for(int i=0; i<n; i++){
    for(int j=0; j<n; j++){
        if(grid[i+1][j] == '.' and i+1 < n){
            dp[i+1][j] += dp[i][j]%MOD;
        }   
        if(grid[i][j+1] == '.' and j+1 < n){
            dp[i][j+1] += dp[i][j]%MOD;
        }

        if(grid[i][j] == '*'){
            dp[i][j] = 0;
        }
    }
}
cout<<dp[n-1][n-1]%MOD<<endl;
\end{lstlisting}

\subsection{2D Prefix Sum (Range Queries)}

\begin{lstlisting}[style=compactcpp]
// 2D Prefix Sum: efficiently computes sum of any rectangular subgrid in O(1)
// Build in O(n*m), query in O(1) using inclusion-exclusion principle
void prefixSum2D(){
    int n,q; cin>>n>>q;
    char forest[n+1][n+1];
 
    for(int i=1; i<=n; i++){
        for(int j=1; j<=n; j++){
            cin>>forest[i][j];
        }
    }
    
    vector<vector<int>> dp(n+1, vector<int> (n+1,0));
    
 
    for(int i=1; i<=n; i++){
        for(int j=1; j<=n; j++){
            dp[i][j] =  dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1];
            if(forest[i][j] == '*') dp[i][j]++;
        }
    }
 
    
 
    for(int i=0; i<q; i++){
        int a,b,c,d;
        cin>>a>>b>>c>>d;
        cout<<dp[c][d] - dp[a-1][d] - dp[c][b-1] + dp[a-1][b-1]<<endl;
    }
    
}
\end{lstlisting}

\subsection{Longest Increasing Subsequence}

\begin{lstlisting}[style=compactcpp]
vector<int> lis(vector<int> const& a) {
    int n = a.size();
    vector<int> d(n, 1), p(n, -1);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (a[j] < a[i] && d[i] < d[j] + 1) {
                d[i] = d[j] + 1;
                p[i] = j;
            }
        }
    }

    int ans = d[0], pos = 0;
    for (int i = 1; i < n; i++) {
        if (d[i] > ans) {
            ans = d[i];
            pos = i;
        }
    }

    vector<int> subseq;
    while (pos != -1) {
        subseq.push_back(a[pos]);
        pos = p[pos];
    }
    reverse(subseq.begin(), subseq.end());
    return subseq;
}
\end{lstlisting}

\subsection{Length of LIS}

\begin{lstlisting}[style=compactcpp]
int lis(vector<ll> const& a) {
    int n = a.size();
    const int INF = 1e9;
    vector<int> d(n+1, INF);
    d[0] = -INF;

    for (int i = 0; i < n; i++) {
        int l = upper_bound(d.begin(), d.end(), a[i]) - d.begin();
        if (d[l-1] < a[i] && a[i] < d[l])
            d[l] = a[i];
    }

    int ans = 0;
    for (int l = 0; l <= n; l++) {
        if (d[l] < INF)
            ans = l;
    }
    return ans;
}
\end{lstlisting}

\subsection{Longest Common Subsequence}

\begin{lstlisting}[style=compactcpp]
// Returns length of LCS for s1[0..m-1], s2[0..n-1]
int lcs(string &s1, string &s2) {
    int m = s1.size();
    int n = s2.size();

    // Initializing a matrix of size (m+1)*(n+1)
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    // Building dp[m+1][n+1] in bottom-up fashion
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (s1[i - 1] == s2[j - 1])
                dp[i][j] = dp[i - 1][j - 1] + 1;
            else
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    }

    // dp[m][n] contains length of LCS for s1[0..m-1]
    // and s2[0..n-1]
    return dp[m][n];
}

\end{lstlisting}

\subsection{LCS with printing}

\begin{lstlisting}[style=compactcpp]
// Longest Common Subsequence with path reconstruction - returns the actual LCS sequence
vector<int> lcs(vector<int> const& a, vector<int> const &b, int n, int m){
    vector<vector<int>> dp (n+1,vector<int> (m+1,0));

    for(int i=1; i<=n; i++){
        for(int j=1;j<=m; j++){
            if(a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1]+1;
            else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
        }
    }

    int ind = dp[n][m];
    // Note: if we have characters, we must set ind+1 size
    // and set the last character as terminal '\0'
    vector<int> arns(ind); 
    int i = n, j = m;

    while(i>0 and j>0){
        if(a[i-1] == b[j-1]){
            arns[ind-1] = a[i-1];
            i--;
            j--;
            ind--;
        }else if(dp[i-1][j] > dp[i][j-1]) i--;
        else j--;
    }

    return arns;
}
\end{lstlisting}

\subsection{Knapsack}

\begin{lstlisting}[style=compactcpp]
    vector<int> prices(n+1);
    vector<int> pages(n+1);
    for(int i=1; i<=n; i++){cin>>prices[i];}
    for(int i=1; i<=n; i++){cin>>pages[i];}

    vector<int> dp(x+1); // dp[prices[i]] -> Max pages I can buy with price i

    dp[0] = 0;
    for(int i=1; i<=n; i++){
        for(int j = x; j>=prices[i]; j--){
            dp[j] = max(dp[j],dp[j-prices[i]]+pages[i]);
        }
    }

    cout<<dp[x]<<endl;
\end{lstlisting}

\subsection{Subset Sum Equal Partition}

\begin{lstlisting}[style=compactcpp]
// Count ways to partition numbers 1..n-1 into two subsets with equal sum
// Uses DP to count subsets that sum to half of total sum
// Divides result by 2 since each partition is counted twice
void SubsetsEqualZum(){
    int n; cin>>n;
 
    int tw = n*(n+1)/2;
    if(tw%2 == 1){
        cout<<0<<endl;
        return;
    }
    tw = tw/2;
 
    vector<int> dp(tw+1,0);
 
    dp[0] = 1;
 
    for(int i=1; i<n; i++){
        for(int j=tw; j>=i; j--){
            dp[j] = (dp[j] + dp[j-i])%MOD;
        }
    }
 
    cout<<dp[tw]<<endl;
    
}
\end{lstlisting}

\subsection{Edit Distance}

\begin{lstlisting}[style=compactcpp]
int editDistance(string &s1, string &s2) {
  
    int m = s1.length();
    int n = s2.length();

    // Create a table to store results of subproblems
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));

    // Fill the known entries in dp[][]
    // If one string is empty, then answer 
    // is length of the other string
    for (int i = 0; i <= m; i++) 
        dp[i][0] = i;
    for (int j = 0; j <= n; j++) 
        dp[0][j] = j; 

    // Fill the rest of dp[][]
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1[i - 1] == s2[j - 1])
                dp[i][j] = dp[i - 1][j - 1];
            else
                dp[i][j] = 1 + min({dp[i][j - 1],  
                                 dp[i - 1][j],   
                                 dp[i - 1][j - 1]});
        }
    }

    return dp[m][n];
} 
\end{lstlisting}

\subsection{Bitmask DP}
\begin{lstlisting}[style=compactcpp]
typedef long long ll;
typedef vector<int> vec;
const ll mod=1e9+7;
const int limit=20;
vector<pair<ll,ll>> dp((1<<limit));
//ascii https://elcodigoascii.com.ar/

inline void solve()
{
    int n; cin>>n;
    ll x; cin>>x;
    vector<ll> weight(n);
    dp[0]={1,0};
    FO(i,n) cin>>weight[i];
    for(ll i=1;i<(1<<n);i++)
    {
        dp[i]={n+1,0};
        for(int j=0;j<n;j++)
        {
            if(i&(1<<j))
            {
                pair<ll,ll> aux=dp[i^(1<<j)];
                if(aux.second+weight[j]<=x){
                    aux.second+=weight[j];
                }
                else{
                    aux.first++;
                    aux.second=weight[j];
                }
                dp[i]=min(dp[i],aux);
            }
        }
    }
    cout<<dp[(1<<n)-1].first<<endl;
}
\end{lstlisting}

\subsection{Digit DP}

\begin{lstlisting}[style=compactcpp]
typedef long long ll;
typedef vector<int> vec;
const ll mod=1e9+7;
ll dp[20][10][2][2];
//ascii https://elcodigoascii.com.ar/

ll mem(int idx,int tight,int prev,int ld,string s)
{
    if(idx==0)
    {
        return 1;
    }
    if(dp[idx][prev][ld][tight]!=-1){
        return dp[idx][prev][ld][tight];
    }
    int k=9;
    if(tight) k=s[s.size()-idx]-'0';
    ll sum=0;
    for(int i=0;i<=k;i++)
    {
        if(ld || prev!=i)
        {
            int new_ld,new_tight;
            if(i==0 && ld) new_ld=1;
            else new_ld=0;
            if(tight && k==i) new_tight=1;
            else new_tight=0;
            sum+=mem(idx-1,new_tight,i,new_ld,s);
        }
    }
    dp[idx][prev][ld][tight]=sum;
    return sum;
}
\end{lstlisting}

\subsection{Double DP}

\begin{lstlisting}[style=compactcpp]
typedef long long ll;
typedef vector<int> vec;
const ll mod=1e9+7;
const ll MAX=1e6+3;
ll dp[MAX][2];
//ascii https://elcodigoascii.com.ar/

inline void solve()
{
    int n; cin>>n;
    dp[n][0]=1;
    dp[n][1]=1;
    for(int i=n-1;i>0;i--)
    {
        dp[i][1]=4*dp[i+1][1]+dp[i+1][0];
        dp[i][0]=2*dp[i+1][0]+dp[i+1][1];
        dp[i][1]%=mod;
        dp[i][0]%=mod;
    }
    cout<<(dp[1][1]+dp[1][0])%mod<<endl;
}
\end{lstlisting}

\section{Math}

\subsection{Miller Rabin }

\begin{lstlisting}[style=compactcpp]
bool MillerRabin(u64 n) { // returns true if n is prime, else returns false.
    if (n < 2)
        return false;

    int r = 0;
    u64 d = n - 1;
    while ((d & 1) == 0) {
        d >>= 1;
        r++;
    }

    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {
        if (n == a)
            return true;
        if (check_composite(n, a, d, r))
            return false;
    }
    return true;
}
\end{lstlisting}

\subsection{Sieve of Erathostenes}

\begin{lstlisting}[style=compactcpp]
int n;
vector<bool> is_prime(n+1, true);
is_prime[0] = is_prime[1] = false;
for (int i = 2; i * i <= n; i++) {
    if (is_prime[i]) {
        for (int j = i * i; j <= n; j += i)
            is_prime[j] = false;
    }
}
\end{lstlisting}

\subsection{Sieve of Eratosthenes (count primes)}
\begin{lstlisting}[style=compactcpp]
int count_primes(int n) {
    const int S = 10000;

    vector<int> primes;
    int nsqrt = sqrt(n);
    vector<char> is_prime(nsqrt + 2, true);
    for (int i = 2; i <= nsqrt; i++) {
        if (is_prime[i]) {
            primes.push_back(i);
            for (int j = i * i; j <= nsqrt; j += i)
                is_prime[j] = false;
        }
    }

    int result = 0;
    vector<char> block(S);
    for (int k = 0; k * S <= n; k++) {
        fill(block.begin(), block.end(), true);
        int start = k * S;
        for (int p : primes) {
            int start_idx = (start + p - 1) / p;
            int j = max(start_idx, p) * p - start;
            for (; j < S; j += p)
                block[j] = false;
        }
        if (k == 0)
            block[0] = block[1] = false;
        for (int i = 0; i < S && start + i <= n; i++) {
            if (block[i])
                result++;
        }
    }
    return result;
}

\end{lstlisting}
\subsection{Segmented Sieve}
\begin{lstlisting}[style=compactcpp]
vector<char> segmentedSieve(long long L, long long R) {
    // generate all primes up to sqrt(R)
    long long lim = sqrt(R);
    vector<char> mark(lim + 1, false);
    vector<long long> primes;
    for (long long i = 2; i <= lim; ++i) {
        if (!mark[i]) {
            primes.emplace_back(i);
            for (long long j = i * i; j <= lim; j += i)
                mark[j] = true;
        }
    }

    vector<char> isPrime(R - L + 1, true);
    for (long long i : primes)
        for (long long j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)
            isPrime[j - L] = false;
    if (L == 1)
        isPrime[0] = false;
    return isPrime;
}
\end{lstlisting}
\subsection{Linear sieve}
\begin{lstlisting}[style=compactcpp]
const int N = 10000000;
vector<int> lp(N+1);
vector<int> pr;

for (int i=2; i <= N; ++i) {
    if (lp[i] == 0) {
        lp[i] = i;
        pr.push_back(i);
    }
    for (int j = 0; i * pr[j] <= N; ++j) {
        lp[i * pr[j]] = pr[j];
        if (pr[j] == lp[i]) {
            break;
        }
    }
}
\end{lstlisting}

\subsection{Sum of divisors}

\begin{lstlisting}[style=compactcpp]
long long SumOfDivisors(long long num) {
    long long total = 1;

    for (int i = 2; (long long)i * i <= num; i++) {
        if (num % i == 0) {
            int e = 0;
            do {
                e++;
                num /= i;
            } while (num % i == 0);

            long long sum = 0, pow = 1;
            do {
                sum += pow;
                pow *= i;
            } while (e-- > 0);
            total *= sum;
        }
    }
    if (num > 1) {
        total *= (1 + num);
    }
    return total;
}
\end{lstlisting}

\subsection{Finding the divisors of a number (Trial Division)}

\begin{lstlisting}[style=compactcpp]
vector<long long> trial_division2(long long n) {
    vector<long long> factorization;
    while (n % 2 == 0) {
        factorization.push_back(2);
        n /= 2;
    }
    for (long long d = 3; d * d <= n; d += 2) {
        while (n % d == 0) {
            factorization.push_back(d);
            n /= d;
        }
    }
    if (n > 1)
        factorization.push_back(n);
    return factorization;
}
\end{lstlisting}

\subsection{Factorials}

\begin{lstlisting}[style=compactcpp]
// Precompute factorials and inverse factorials
void precompute(ll n = MAXN - 1) {
    factorial[0] = factorial[1] = 1;
    
    // Compute factorials
    for (ll i = 2; i <= n; i++) {
        factorial[i] = (factorial[i - 1] * i) % MOD;
    }
    
    // Compute inverse factorials efficiently
    inv_factorial[n] = modInv(factorial[n]);
    for (ll i = n - 1; i >= 0; i--) {
        inv_factorial[i] = 
            (inv_factorial[i + 1] * (i + 1)) % MOD;
    }
}
 
\end{lstlisting}

\subsection{Binpow}
\begin{lstlisting}[style=compactcpp]
long long binpow(long long a, long long b) {
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}
\end{lstlisting}
\subsection{Modulo Inverse}
\begin{lstlisting}[style=compactcpp]
int modInverse(int A, int M) {
    int m0 = M;
    int y = 0, x = 1;

    if (M == 1)
        return 0;

    while (A > 1) {
        // q is quotient
        int q = A / M;
        int t = M;

        // m is remainder now, process same as
        // Euclid's algo
        M = A % M, A = t;
        t = y;

        // Update y and x
        y = x - q * y;
        x = t;
    }

    // Make x positive
    if (x < 0)
        x += m0;

    return x;
}
\end{lstlisting}

\subsection{BinPow Modulo Inv}
\begin{lstlisting}[style=compactcpp]
ll modInv(ll a, ll mod = MOD) {
    return power(a, mod - 2, mod);
}

\end{lstlisting}

\subsection{XOR Basis (Linear Basis)}
\begin{lstlisting}[style=compactcpp]
// XOR Basis: finds linearly independent set of numbers for XOR operations
// Counts number of distinct XOR subset sums (2^sz where sz is basis size)
const int DIM = 30; // or 60 for long long
int basis[DIM];
int sz = 0;

void add(int val){
    for(int i=DIM-1;i>=0;i--)
    {
        if((val&(1<<i))==0) continue;
        if(basis[i]==0){
            basis[i]=val;
            sz++;
            return;
        }
        val^=basis[i];
    }
}

// Number of subset xors
inline void solve()
{
    int n; cin>>n;
    FO(i,n){
        int aux; cin>>aux;
        add(aux);
    }
    
    cout<<(1<<sz)<<endl;
}
\end{lstlisting}

\subsection{Binomial Coefficients}
\begin{lstlisting}[style=compactcpp]
long long binomial_coefficient(int n, int k) {
    return factorial[n] * inverse_factorial[k] % m * inverse_factorial[n - k] % m;
}
\end{lstlisting}
\subsection{Newton Method (Sqrt and iSqrt)}
\begin{lstlisting}[style=compactcpp]
double sqrt_newton(double n) {
    const double eps = 1E-15;
    double x = 1;
    for (;;) {
        double nx = (x + n / x) / 2;
        if (abs(x - nx) < eps)
            break;
        x = nx;
    }
    return x;
}

int isqrt_newton(int n) {
    int x = 1;
    bool decreased = false;
    for (;;) {
        int nx = (x + n / x) >> 1;
        if (x == nx || nx > x && decreased)
            break;
        decreased = nx < x;
        x = nx;
    }
    return x;
}
\end{lstlisting}
\subsection{Integration with Simpson Method}
\begin{lstlisting}[style=compactcpp]
const int N = 1000 * 1000; // number of steps (already multiplied by 2)

double simpson_integration(double a, double b){
    double h = (b - a) / N;
    double s = f(a) + f(b); // a = x_0 and b = x_2n
    for (int i = 1; i <= N - 1; ++i) { // Refer to final Simpson's formula
        double x = a + h * i;
        s += f(x) * ((i & 1) ? 4 : 2);
    }
    s *= h / 3;
    return s;
}
\end{lstlisting}
\subsection{Ternary Search}
\begin{lstlisting}[style=compactcpp]
double ternary_search(double l, double r) {
    double eps = 1e-9;              //set the error limit here
    while (r - l > eps) {
        double m1 = l + (r - l) / 3;
        double m2 = r - (r - l) / 3;
        double f1 = f(m1);      //evaluates the function at m1
        double f2 = f(m2);      //evaluates the function at m2
        if (f1 < f2)
            l = m1;
        else
            r = m2;
    }
    return f(l);                    //return the maximum of f(x) in [l, r]
}
\end{lstlisting}
\subsection{DP Pascal triangle 1D}
\begin{lstlisting}[style=compactcpp]
int binomialCoeff(int n, int k) {
    vector<int> dp(k + 1);

      // nC0 is 1
    dp[0] = 1; 

    for (int i = 1; i <= n; i++) {
      
        // Compute next row of pascal triangle using
        // the previous row
        for (int j = min(i, k); j > 0; j--)
            dp[j] = dp[j] + dp[j - 1];
    }
    return dp[k];
}
\end{lstlisting}
\subsection{DP Pascal triangle 2D}
\begin{lstlisting}[style=compactcpp]
    // Returns value of Binomial Coefficient C(n, k)
int binomialCoeff(int n, int k) {
      vector<vector<int>> dp(n + 1, vector<int> (k + 1));
  
    // Calculate value of Binomial Coefficient
    // in bottom up manner
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= min(i, k); j++) {
          
            // Base Cases
            if (j == 0 || j == i)
                dp[i][j] = 1;

            // Calculate value using previously
            // stored values
            else
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
        }
    }

    return dp[n][k];
}
    
\end{lstlisting}


\subsection{Euler's Totient}

\begin{lstlisting}[style=compactcpp]
void phi_1_to_n(int n) {
    vector<int> phi(n + 1);
    for (int i = 0; i <= n; i++)
        phi[i] = i;

    for (int i = 2; i <= n; i++) {
        if (phi[i] == i) {
            for (int j = i; j <= n; j += i)
                phi[j] -= phi[j] / i;
        }
    }
}

void phi_1_to_n(int n) {
    vector<int> phi(n + 1);
    phi[0] = 0;
    phi[1] = 1;
    for (int i = 2; i <= n; i++)
        phi[i] = i - 1;

    for (int i = 2; i <= n; i++)
        for (int j = 2 * i; j <= n; j += i)
              phi[j] -= phi[i];
}
\end{lstlisting}

\subsection{Diophantine equations}

\begin{lstlisting}[style=compactcpp]
void shift_solution(int & x, int & y, int a, int b, int cnt) {
    x += cnt * b;
    y -= cnt * a;
}

int find_all_solutions(int a, int b, int c, int minx, int maxx, int miny, int maxy) {
    int x, y, g;
    if (!find_any_solution(a, b, c, x, y, g))
        return 0;
    a /= g;
    b /= g;

    int sign_a = a > 0 ? +1 : -1;
    int sign_b = b > 0 ? +1 : -1;

    shift_solution(x, y, a, b, (minx - x) / b);
    if (x < minx)
        shift_solution(x, y, a, b, sign_b);
    if (x > maxx)
        return 0;
    int lx1 = x;

    shift_solution(x, y, a, b, (maxx - x) / b);
    if (x > maxx)
        shift_solution(x, y, a, b, -sign_b);
    int rx1 = x;

    shift_solution(x, y, a, b, -(miny - y) / a);
    if (y < miny)
        shift_solution(x, y, a, b, -sign_a);
    if (y > maxy)
        return 0;
    int lx2 = x;

    shift_solution(x, y, a, b, -(maxy - y) / a);
    if (y > maxy)
        shift_solution(x, y, a, b, sign_a);
    int rx2 = x;

    if (lx2 > rx2)
        swap(lx2, rx2);
    int lx = max(lx1, lx2);
    int rx = min(rx1, rx2);

    if (lx > rx)
        return 0;
    return (rx - lx) / abs(b) + 1;
}
\end{lstlisting}

\subsection{Discrete Log}

\begin{lstlisting}[style=compactcpp]
// Returns minimum x for which a ^ x % m = b % m.
int solve(int a, int b, int m) {
    a %= m, b %= m;
    int k = 1, add = 0, g;
    while ((g = gcd(a, m)) > 1) {
        if (b == k)
            return add;
        if (b % g)
            return -1;
        b /= g, m /= g, ++add;
        k = (k * 1ll * a / g) % m;
    }

    int n = sqrt(m) + 1;
    int an = 1;
    for (int i = 0; i < n; ++i)
        an = (an * 1ll * a) % m;

    unordered_map<int, int> vals;
    for (int q = 0, cur = b; q <= n; ++q) {
        vals[cur] = q;
        cur = (cur * 1ll * a) % m;
    }

    for (int p = 1, cur = k; p <= n; ++p) {
        cur = (cur * 1ll * an) % m;
        if (vals.count(cur)) {
            int ans = n * p - vals[cur] + add;
            return ans;
        }
    }
    return -1;
}
\end{lstlisting}

\section{Polynomials}

\subsection{FFT}

\begin{lstlisting}[style=compactcpp]
using cd = complex<double>;
const double PI = acos(-1);

int reverse(int num, int lg_n) {
    int res = 0;
    for (int i = 0; i < lg_n; i++) {
        if (num & (1 << i))
            res |= 1 << (lg_n - 1 - i);
    }
    return res;
}

void fft(vector<cd> & a, bool invert) {
    int n = a.size();
    int lg_n = 0;
    while ((1 << lg_n) < n)
        lg_n++;

    for (int i = 0; i < n; i++) {
        if (i < reverse(i, lg_n))
            swap(a[i], a[reverse(i, lg_n)]);
    }

    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            cd w(1);
            for (int j = 0; j < len / 2; j++) {
                cd u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }

    if (invert) {
        for (cd & x : a)
            x /= n;
    }
}

vector<int> multiply(vector<int> const& a, vector<int> const& b) {
    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n = 1;
    while (n < a.size() + b.size()) 
        n <<= 1;
    fa.resize(n);
    fb.resize(n);

    fft(fa, false);
    fft(fb, false);
    for (int i = 0; i < n; i++)
        fa[i] *= fb[i];
    fft(fa, true);

    vector<int> result(n);
    for (int i = 0; i < n; i++)
        result[i] = round(fa[i].real());
    return result;
}

// Normalization

int carry = 0;
for (int i = 0; i < n; i++){
    result[i] += carry;
    carry = result[i] / 10;
    result[i] %= 10;
}

\end{lstlisting}

\subsection{FFT Alternative Implementation}

\begin{lstlisting}[style=compactcpp]
// Fast Fourier Transform using bit-reversal and Cooley-Tukey algorithm
const ll MOD = 1e9+7;
 
const int MAX = pow(2,18);
 
typedef complex<double> cd;
double PI = acos(-1);
 
vector<cd> fft(vector<cd> a, int d = 1) {
    int n = a.size();
    vector<cd> r(n);
 
    for (int k = 0; k < n; k++) {
        int b = 0;
        for (int z = 1; z < n; z *= 2) {
            b *= 2;
            if (k & z)
                b++;
        }
        r[b] = a[k];
    }
 
    for (int m = 2; m <= n; m *= 2) {
        cd wm = exp(cd{0, d * 2 * PI / m});
 
        for (int k = 0; k < n; k += m) {
            cd w = 1;
            for (int j = 0; j < m / 2; j++) {
                cd u = r[k + j];
                cd t = w * r[k + j + m / 2];
                r[k + j] = u + t;
                r[k + j + m / 2] = u - t;
                w = w * wm;
            }
        }
    }
 
    if (d == -1) {
        for (int i = 0; i < n; i++)
            r[i] /= n;
    }
 
    return r;
}
\end{lstlisting}

\subsection{NTT}

\begin{lstlisting}[style=compactcpp]
const int mod = 7340033;
const int root = 5;
const int root_1 = 4404020;
const int root_pw = 1 << 20;

void fft(vector<int> & a, bool invert) {
    int n = a.size();

    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j ^= bit;
        j ^= bit;

        if (i < j)
            swap(a[i], a[j]);
    }

    for (int len = 2; len <= n; len <<= 1) {
        int wlen = invert ? root_1 : root;
        for (int i = len; i < root_pw; i <<= 1)
            wlen = (int)(1LL * wlen * wlen % mod);

        for (int i = 0; i < n; i += len) {
            int w = 1;
            for (int j = 0; j < len / 2; j++) {
                int u = a[i+j], v = (int)(1LL * a[i+j+len/2] * w % mod);
                a[i+j] = u + v < mod ? u + v : u + v - mod;
                a[i+j+len/2] = u - v >= 0 ? u - v : u - v + mod;
                w = (int)(1LL * w * wlen % mod);
            }
        }
    }

    if (invert) {
        int n_1 = inverse(n, mod);
        for (int & x : a)
            x = (int)(1LL * x * n_1 % mod);
    }
}
\end{lstlisting}

\subsection{Berlekamp Messey}

\begin{lstlisting}[style=compactcpp]
vector<T> berlekampMassey(const vector<T> &s) {
    vector<T> c;    // the linear recurrence sequence we are building
    vector<T> oldC; // the best previous version of c to use (the one with the rightmost left endpoint)
    int f = -1;     // the index at which the best previous version of c failed on
    for (int i=0; i<(int)s.size(); i++) {
        // evaluate c(i)
        // delta = s_i - \sum_{j=1}^n c_j s_{i-j}
        // if delta == 0, c(i) is correct
        T delta = s[i];
        for (int j=1; j<=(int)c.size(); j++)
            delta -= c[j-1] * s[i-j];   // c_j is one-indexed, so we actually need index j - 1 in the code
        if (delta == 0)
            continue;   // c(i) is correct, keep going
        // now at this point, delta != 0, so we need to adjust it
        if (f == -1) {
            // this is the first time we're updating c
            // s_i was the first non-zero element we encountered
            // we make c of length i + 1 so that s_i is part of the base case
            c.resize(i + 1);
            mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
            for (T &x : c)
                x = rng();  // just to prove that the initial values don't matter in the first step, I will set to random values
            f = i;
        } else {
            // we need to use a previous version of c to improve on this one
            // apply the 5 steps to build d
            // 1. set d equal to our chosen sequence
            vector<T> d = oldC;
            // 2. multiply the sequence by -1
            for (T &x : d)
                x = -x;
            // 3. insert a 1 on the left
            d.insert(d.begin(), 1);
            // 4. multiply the sequence by delta / d(f + 1)
            T df1 = 0;  // d(f + 1)
            for (int j=1; j<=(int)d.size(); j++)
                df1 += d[j-1] * s[f+1-j];
            assert(df1 != 0);
            T coef = delta / df1;   // storing this in outer variable so it's O(n^2) instead of O(n^2 log MOD)
            for (T &x : d)
                x *= coef;
            // 5. insert i - f - 1 zeros on the left
            vector<T> zeros(i - f - 1);
            zeros.insert(zeros.end(), d.begin(), d.end());
            d = zeros;
            // now we have our new recurrence: c + d
            vector<T> temp = c; // save the last version of c because it might have a better left endpoint
            c.resize(max(c.size(), d.size()));
            for (int j=0; j<(int)d.size(); j++)
                c[j] += d[j];
            // finally, let's consider updating oldC
            if (i - (int) temp.size() > f - (int) oldC.size()) {
                // better left endpoint, let's update!
                oldC = temp;
                f = i;
            }
        }
    }
    return c;
}
\end{lstlisting}

\section{Linear Algebra}

\subsection{Determinant of a Matrix}

\begin{lstlisting}[style=compactcpp]
const double EPS = 1E-9;
int n;
vector < vector<double> > a (n, vector<double> (n));

double det = 1;
for (int i=0; i<n; ++i) {
    int k = i;
    for (int j=i+1; j<n; ++j)
        if (abs (a[j][i]) > abs (a[k][i]))
            k = j;
    if (abs (a[k][i]) < EPS) {
        det = 0;
        break;
    }
    swap (a[i], a[k]);
    if (i != k)
        det = -det;
    det *= a[i][i];
    for (int j=i+1; j<n; ++j)
        a[i][j] /= a[i][i];
    for (int j=0; j<n; ++j)
        if (j != i && abs (a[j][i]) > EPS)
            for (int k=i+1; k<n; ++k)
                a[j][k] -= a[i][k] * a[j][i];
}

cout << det;
\end{lstlisting}

\subsection{Rank of a Matrix}
\begin{lstlisting}[style=compactcpp]
const double EPS = 1E-9;

int compute_rank(vector<vector<double>> A) {
    int n = A.size();
    int m = A[0].size();

    int rank = 0;
    vector<bool> row_selected(n, false);
    for (int i = 0; i < m; ++i) {
        int j;
        for (j = 0; j < n; ++j) {
            if (!row_selected[j] && abs(A[j][i]) > EPS)
                break;
        }

        if (j != n) {
            ++rank;
            row_selected[j] = true;
            for (int p = i + 1; p < m; ++p)
                A[j][p] /= A[j][i];
            for (int k = 0; k < n; ++k) {
                if (k != j && abs(A[k][i]) > EPS) {
                    for (int p = i + 1; p < m; ++p)
                        A[k][p] -= A[j][p] * A[k][i];
                }
            }
        }
    }
    return rank;
}

\end{lstlisting}


\subsection{Gauss-Jordan}

\begin{lstlisting}[style=compactcpp]
const double EPS = 1e-9;
const int INF = 2; // it doesn't actually have to be infinity or a big number

int gauss (vector < vector<double> > a, vector<double> & ans) {
    int n = (int) a.size();
    int m = (int) a[0].size() - 1;

    vector<int> where (m, -1);
    for (int col=0, row=0; col<m && row<n; ++col) {
        int sel = row;
        for (int i=row; i<n; ++i)
            if (abs (a[i][col]) > abs (a[sel][col]))
                sel = i;
        if (abs (a[sel][col]) < EPS)
            continue;
        for (int i=col; i<=m; ++i)
            swap (a[sel][i], a[row][i]);
        where[col] = row;

        for (int i=0; i<n; ++i)
            if (i != row) {
                double c = a[i][col] / a[row][col];
                for (int j=col; j<=m; ++j)
                    a[i][j] -= a[row][j] * c;
            }
        ++row;
    }

    ans.assign (m, 0);
    for (int i=0; i<m; ++i)
        if (where[i] != -1)
            ans[i] = a[where[i]][m] / a[where[i]][i];
    for (int i=0; i<n; ++i) {
        double sum = 0;
        for (int j=0; j<m; ++j)
            sum += ans[j] * a[i][j];
        if (abs (sum - a[i][m]) > EPS)
            return 0;
    }

    for (int i=0; i<m; ++i)
        if (where[i] == -1)
            return INF;
    return 1;
}
\end{lstlisting}


\subsection{Matrix Exponentiation}
\begin{lstlisting}[style=compactcpp]
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

const ll MOD = 1e9 + 7;

using Matrix = array<array<ll, 2>, 2>;

Matrix mul(Matrix a, Matrix b) {
	Matrix res = {{{0, 0}, {0, 0}}};
	for (int i = 0; i < 2; i++) {
		for (int j = 0; j < 2; j++) {
			for (int k = 0; k < 2; k++) {
				res[i][j] += a[i][k] * b[k][j];
				res[i][j] %= MOD;
			}
		}
	}

	return res;
}

int main() {
	ll n;
	cin >> n;

	Matrix base = {{{1, 0}, {0, 1}}};
	Matrix m = {{{1, 1}, {1, 0}}};

	for (; n > 0; n /= 2, m = mul(m, m)) {
		if (n & 1) base = mul(base, m);
	}

	cout << base[0][1];
}
\end{lstlisting}

\subsection{Matrix Multiplication and Exponentiation (General)}

\begin{lstlisting}[style=compactcpp]
// Matrix multiplication: multiplies A (n x m) with B (m x p) to get result (n x p)
vector<vector<int>> mat_mult(vector<vector<int>> &A, vector<vector<int>> &B, int n, int m, int p){
    vector<vector<int>> arns(n,vector<int> (p));
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            for(int k=0; k<p; k++){ 
                arns[i][k] += A[i][j] * B[j][k];
                arns[i][k]%=MOD;
            }   
        }
    }
 
    return arns;
}

// Matrix exponentiation: computes A^n for a square matrix A
vector<vector<int>> mat_pow(vector<vector<int>> &A, int n){
    int sz = A.size();
    vector<vector<int>> arns(sz,vector<int> (sz,0));
    for(int i=0; i<sz; i++)
        arns[i][i] = 1;
    while(n>0){
        if(n&1) arns = mat_mult(arns,A,sz,sz,sz);
        A = mat_mult(A,A,sz,sz,sz);
        n>>=1;
    }
    return arns;
}
\end{lstlisting}

\section{Geometry}

\subsection{Line Segment Intersection}
\begin{lstlisting}[style=compactcpp]
// BeginCodeSnip{Point Class}
struct Point {
	int x, y;
	Point(int a = 0, int b = 0) : x(a), y(b) {}

	friend istream &operator>>(istream &in, Point &p) {
		int x, y;
		in >> p.x >> p.y;
		return in;
	}
};
// EndCodeSnip

int sign(long long num) {
	if (num < 0) {
		return -1;
	} else if (num == 0) {
		return 0;
	} else {
		return 1;
	}
}

long long trigonometric_sense(Point p, Point p1, Point p2) {
	return sign(1LL * (p1.x - p.x) * (p2.y - p.y) -
	            1LL * (p2.x - p.x) * (p1.y - p.y));
}

// Check if the rectangles with [P1, P2] and [P3, P4] as diagonals intersect
bool quick_check(Point p1, Point p2, Point p3, Point p4) {
	int x1, x2, x3, x4, y1, y2, y3, y4;
	x1 = min(p1.x, p2.x), x2 = max(p1.x, p2.x);
	y1 = min(p1.y, p2.y), y2 = max(p1.y, p2.y);
	x3 = min(p3.x, p4.x), x4 = max(p3.x, p4.x);
	y3 = min(p3.y, p4.y), y4 = max(p3.y, p4.y);
	return x2 < x3 || x4 < x1 || y2 < y3 || y4 < y1;
}

bool check(Point p1, Point p2, Point p3, Point p4) {
	if (trigonometric_sense(p1, p2, p3) * trigonometric_sense(p1, p2, p4) > 0) {
		return false;
	}
	if (trigonometric_sense(p3, p4, p1) * trigonometric_sense(p3, p4, p2) > 0) {
		return false;
	}
	return true;
}

int main() {
	int test_num;
	cin >> test_num;
	for (int t = 0; t < test_num; t++) {
		Point p1, p2, p3, p4;
		cin >> p1 >> p2 >> p3 >> p4;

		if (quick_check(p1, p2, p3, p4)) {
			cout<<"NO"<<endl;
		} else if (check(p1, p2, p3, p4)) {
			cout<<"YES"<<endl;
		} else {
			cout<<"NO"<<endl;
		}
	}
}
\end{lstlisting}
\subsection{Minimum Euclidian Distance}
\begin{lstlisting}[style=compactcpp]
const ll mod=1e9+7;
const ll MAX=8e18;
const ll limit=1e9+1;
//ascii https://elcodigoascii.com.ar/

ll distance(point a,point b){
    return (a.X-b.X)*(a.X-b.X)+(a.Y-b.Y)*(a.Y-b.Y);
}

inline void solve()
{
    int n; cin>>n;
    vector<point> sortedX(n);
    set<point> sortedY;
    FO(i,n)
    {
        ll x,y; cin>>x>>y;
        sortedX[i]=make_pair(x,y);
    }
    sort(all(sortedX));
    sortedY.insert(make_pair(sortedX[0].Y,sortedX[0].X));
    ll d,minSquare=MAX;
    int j=0;
    FOR(i,1,n)
    {
        d=ceil(sqrt(minSquare));
        while(sortedX[i].X-sortedX[j].X>d)
        {
            sortedY.erase(make_pair(sortedX[j].Y,sortedX[j].X));
            j++;
        }
        auto lower=sortedY.lower_bound(make_pair(sortedX[i].Y-d,0));
        auto upper=sortedY.upper_bound(make_pair(sortedX[i].Y+d,0));
        for(auto pointer=lower;pointer!=upper;pointer++)
        {
            minSquare=min(minSquare,distance(*pointer,make_pair(sortedX[i].Y,sortedX[i].X)));
        }
        sortedY.insert(make_pair(sortedX[i].Y,sortedX[i].X));
    }
    cout<<minSquare<<endl;
}

\end{lstlisting}
\subsection{Point in polygon}
\begin{lstlisting}[style=compactcpp]
struct point{
    ll x,y;
    void show(){
        cout<<x<<" "<<y<<endl;
    }
};

int sign(ll a){
    if(a<0) return -1;
    if(a==0) return 0;
    if(a>0) return 1;
}

int signCP(point p,point p1,point p2)
{
    return sign(1LL*((p1.x-p.x)*(p2.y-p.y)-(p1.y-p.y)*(p2.x-p.x)));
}

bool intersect(point n, point m,point a,point b)
{
    if(signCP(n,a,b)*signCP(m,a,b)>0) return false;
    if(signCP(a,n,m)*signCP(b,n,m)>0) return false;
    return true;
}

bool inside(point a,point b,point c){
    return a.x>=min(b.x,c.x) && a.x<=max(b.x,c.x) && a.y>=min(b.y,c.y)
    && a.y<=max(b.y,c.y);
}

inline void solve()
{
    int n,m; cin>>n>>m;
    vector<point> vertices(n);
    FO(i,n)
    {
        cin>>vertices[i].x>>vertices[i].y;
    }
    point query,par,init,first,second;
    int counter;
    int resta=0;
    FO(i,m)
    {
        resta=0;
        counter=0;
        cin>>query.x>>query.y;
        par.x=query.x;
        par.y=-MAX-1;
        init.x=vertices[0].x;
        init.y=vertices[0].y;
        first.x=init.x;
        first.y=init.y;
        bool ver=false;
        for(int j=1;j<=n;j++)
        {
            second.x=vertices[j%n].x;
            second.y=vertices[j%n].y;
            point AB,u;
            AB.x=second.x-first.x;
            AB.y=second.y-first.y;
            u.x=second.x-query.x;
            u.y=second.y-query.y;
            if((AB.x*u.y-AB.y*u.x)==0 && inside(query,first,second)){
                cout<<"BOUNDARY"<<endl;
                ver=true;
                break;
            }
            if(intersect(query,par,first,second) && first.x<=query.x && query.x<second.x)
            {
                counter++;
            }
            if(intersect(query,par,first,second) && second.x<=query.x && query.x<first.x){
                counter++;
            }
            first.x=second.x;
            first.y=second.y;
        }
        point AB,u;
        AB.x=init.x-first.x;
        AB.y=init.y-first.y;
        u.x=init.x-query.x;
        u.y=init.y-query.y;
        if(!ver){
            //if(intersect(query,par,first,init)) counter++;
            if((counter)&1) cout<<"INSIDE";
            else cout<<"OUTSIDE";
            cout<<endl;
        }
    }
}
\end{lstlisting}
\subsection{Point Location Test}
\begin{lstlisting}[style=compactcpp]
struct point{
    double x,y;
};

struct Vector{
    double a=0,b=0;
    void getVector(point p1,point p2){
        a=p2.x-p1.x;
        b=p2.y-p1.y;
    }

    double getModulo(){
        return pow(a*a+b*b,0.5);
    }

    Vector getUnitarian(){
        Vector x;
        x.a=a/getModulo();
        x.b=b/getModulo();
        //cout<<x.a<<" "<<x.b<<endl;
        return x;
    }

};

double dotProduct(Vector x,Vector y)
{
    return x.a*y.a+x.b*y.b;
}

double CrossProduct(Vector x,Vector y)
{
    return x.a*y.b-x.b*y.a;
}

inline void solve()
{
    
    point p1,p2,p3,p4;
    cin>>p1.x>>p1.y>>p2.x>>p2.y>>p3.x>>p3.y;
    Vector u,v,t;
    u.getVector(p1,p3);
    //cout<<u.a<<" "<<u.b<<endl;
    v.getVector(p2,p3);
    if(CrossProduct(u,v)>0) cout<<"LEFT"<<endl;
    else if(CrossProduct(u,v)<0) cout<<"RIGHT"<<endl;
    else cout<<"TOUCH"<<endl;
    
}

\end{lstlisting}
\subsection{Polygon Area}
\begin{lstlisting}[style=compactcpp]
struct point{
    ll x,y;
};

ll CrossP(point a,point b){
    return a.x*b.y-a.y*b.x;
}

inline void solve()
{
    int n; cin>>n;
    ll res=0;
    point p1,p2,p3;
    cin>>p3.x>>p3.y;
    p1.x=p3.x;
    p1.y=p3.y;
    FO(i,n-1)
    {
        cin>>p2.x>>p2.y;
        res+=CrossP(p1,p2);
        p1.x=p2.x;
        p1.y=p2.y;
    }
    res+=CrossP(p1,p3);
    cout<<abs(res)<<endl;
}
\end{lstlisting}
\subsection{Convex Hull}
\begin{lstlisting}[style=compactcpp]
const ll mod=1e9+7;
const ll limit=4e9;
//ascii https://elcodigoascii.com.ar/

int orientation(point a,point b,point c){
    ll ori=(b.y-c.y)*(b.x-a.x)-(b.y-a.y)*(b.x-c.x);
    if(ori==0) return 0;
    if(ori>0) return 1;
    return 2;
}

void getLastTwo(point &a,point &b,stack<point> &s)
{
    a=s.top();
    s.pop();
    b=s.top();
    s.pop();
}

void show(point a){
    cout<<a.x<<" "<<a.y<<endl;
}

//Graham scan
 
void solve(){
    int n; cin>>n;
    vector<point> puntos(n);
    FO(i,n){
        ll a,b; cin>>a>>b;
        puntos[i]=make_pair(a,b);
    }
    sort(all(puntos));
    //Lower Part
    stack<point> lower;
    FO(i,n)
    {
        if(lower.size()<2){
            lower.push(puntos[i]);
            continue;
        }
        point a,b;
        getLastTwo(a,b,lower);
        if(orientation(a,b,puntos[i])<2)
        {
            lower.push(b);
            lower.push(a);
            lower.push(puntos[i]);
        }
        else{
            lower.push(b);
            i--;
        }
    }
    stack<point> upper;
    for(int i=n-1;i>=0;i--)
    {
        if(upper.size()<2){
            upper.push(puntos[i]);
            continue;
        }
        point a,b;
        getLastTwo(a,b,upper);
        if(orientation(a,b,puntos[i])<2)
        {
            upper.push(b);
            upper.push(a);
            upper.push(puntos[i]);
        }
        else{
            upper.push(b);
            i++;
        }
    }

    set<point> res;

    while(!lower.empty()){
        res.insert(lower.top());
        lower.pop();
    }
    while(!upper.empty()){
        res.insert(upper.top());
        upper.pop();
    }
    cout<<res.size()<<endl;
    for(auto c:res) show(c);
}
\end{lstlisting}

\subsection{Complex point}

\begin{lstlisting}[style=compactcpp]
typedef double T;
typedef complex<T> pt;
#define x real()
#define y imag()
 
typedef long long ll;
typedef vector<int> vec;
const ll mod=1e9+7;
const int MAX=2e5+3;

//ascii https://elcodigoascii.com.ar/

T norma(pt a){return a.x*a.x+a.y*a.y;}


int sgn(T X){
    return (T(0)<X)-(T(0)>X);
}


pt translate(pt a,pt v){return a+v;}
pt scale(pt p,pt c,T factor){return c+(p-c)*factor;}
pt rot(pt p,T a){return p*polar(1.0,a);}
pt perp(pt p){return pt({-p.y,p.x});}
pt linearFunc(pt p,pt q,pt r,pt fp,pt fq){
    return fp+(r-p)*(fq-fp)/(q-p);
}
T dot(pt v,pt w){ return v.x*w.x+v.y*w.y;}
T cross(pt v,pt w){ return v.x*w.y-v.y*w.x;}

bool isperp(pt a,pt b){return dot(a,b)==0;}

double angle(pt v,pt w){
    return acos(clamp(dot(v,w)/abs(v)/abs(w),-1.0,-1.0));
}

T orientation(pt a,pt b,pt c){return cross(b-a,c-a);}

bool inAngle(pt a,pt b,pt c,pt p){
    if(orientation(a,b,c)<0) swap(b,c);
    return sgn(orientation(a,b,p))*sgn(orientation(a,c,p))<=0;
}

bool isconvex(vector<pt> p){
    bool hasPos=false,hasNeg=false;
    for(int i=0,n=p.size();i<n;i++){
        int o=orientation(p[i],p[(i+1)%n],p[(i+2)%n]);
        if(o>0) hasPos=true;
        if(o<0) hasNeg=true;
    }
    return !(hasPos && hasNeg);
}

inline void solve()
{
    pt p{3,-4};
    p+=pt({1,2});
    cout<<p<<endl;
    cout<<norma(p)<<endl;
}
\end{lstlisting}

\subsection{Polar sort}

\begin{lstlisting}[style=compactcpp]
#define x real() 
#define y imag()
 
typedef long long ll;
typedef double T;
typedef complex<T> pt;
typedef vector<int> vec;
const ll mod=1e9+7;
const int MAX=2e5+3;

T cross(pt v,pt w){ return v.x*w.y-v.y*w.x;}
T norma(pt a){return a.x*a.x+a.y*a.y;}
//ascii https://elcodigoascii.com.ar/

bool half(pt p){
    assert(p.x!=0 || p.y!=0);
    return p.y>0 || (p.y==0 && p.x<0);
}

void polarSort(vector<pt> &v){
    sort(all(v),[](pt v,pt w){
        return make_tuple(half(v),0)<make_tuple(half(w),cross(v,w));
    });
}

void polarSortNorm(vector<pt> &v){
    sort(all(v),[](pt v,pt w){
        return make_tuple(half(v),0,norma(v))<make_tuple(half(w),cross(v,w),norma(w));
    });
}
inline void solve()
{

}
\end{lstlisting}

\section{Strings}

\subsection{Marranadas de Quique}
\begin{lstlisting}[style=compactcpp]

//To Upper and Lower
transform(s.begin(), s.end(), s.begin(), ::toupper);
transform(s.begin(), s.end(), s.begin(), ::tolower);

// From i to the end
string a = s.substr(i);
// From i to j
string a = s.substr(i,j);

int a;
int b;
int c;
char comma;
char colon;

// Createa a stringstream object
stringstream ss(fullString);
// Extract the strings
ss >> a >> colon >> b >> comma >> c;

\end{lstlisting}

\subsection{KMP Algorithm}
\begin{lstlisting}[style=compactcpp]
// LPS for s, lps[i] could also be defined as the longest prefix which is also a proper suffix
vi computeLPS(string s){
    size_t len = 0;
    size_t M = s.size();
    vi lps(M, 0);

    size_t i = 1;
    while(i < M) {
        if( s[i] == s[len]){
            len++;
            lps[i] = len;
            i++;
        } else {
            if(len != 0){
                len = lps[len-1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }

    return lps;
}

// Get number of occurrences of a pattern in a text using KMP
// O(N+M)
size_t KMPOccurrences(string pattern, string text){
    vi lps = computeLPS(pattern); // LPS array

    size_t M = pattern.size();
    size_t N = text.size();

    size_t i = 0; // Index for text
    size_t j = 0; // Index for pattern

    size_t cnt = 0; // Counter

    while ((N - i) >= (M - j)) {
        // Watch for the pattern
        if (pattern[j] == text[i]) {
            j++;
            i++;
        }

        // If the full match found
        if (j == M) {
            cnt++;
            j = lps[j - 1];
        }

        // Mismatch after j matches
        else if (i < N && pattern[j] != text[i]) {
            // Do not match lps[0..lps[j-1]] characters,
            // they will match anyway
            if (j != 0)
                j = lps[j - 1];
            else
                i++;
        }
    }

    return cnt;
}

\end{lstlisting}

\subsection{Rolling Hash}
\begin{lstlisting}[style=compactcpp]
// Rolling hash
struct Hash {
    // Prime number and modulo
    long long p = 31, m = 1e9 + 7;
    long long hash_value;
    Hash(const string& s)
    {
        long long hash_so_far = 0;
        long long p_pow = 1;
        const long long n = s.length();
        for (long long i = 0; i < n; ++i) {
            hash_so_far
                = (hash_so_far + (s[i] - 'a' + 1) * p_pow)
                  % m;
            p_pow = (p_pow * p) % m;
        }
        hash_value = hash_so_far;
    }
    bool operator==(const Hash& other)
    {
        return (hash_value == other.hash_value);
    }
};

// Usage
int main(){
    string s = "hello";

    return 0;
}

\end{lstlisting}

\subsection{Hash marrano}

\begin{lstlisting}[style=compactcpp]
vector<vector<int>> group_identical_strings(vector<string> const& s) {
    int n = s.size();
    vector<pair<long long, int>> hashes(n);
    for (int i = 0; i < n; i++)
        hashes[i] = {compute_hash(s[i]), i};

    sort(hashes.begin(), hashes.end());

    vector<vector<int>> groups;
    for (int i = 0; i < n; i++) {
        if (i == 0 || hashes[i].first != hashes[i-1].first)
            groups.emplace_back();
        groups.back().push_back(hashes[i].second);
    }
    return groups;
}
\end{lstlisting}

\subsection{Suffix Array}

\begin{lstlisting}[style=compactcpp]
// Structure to store information of a suffix
struct suffix
{
    int index;
    char *suff;
};
 
// A comparison function used by sort() to compare two suffixes
int cmp(struct suffix a, struct suffix b)
{
    return strcmp(a.suff, b.suff) < 0? 1 : 0;
}
 
// This is the main function that takes a string 'txt' of size n as an
// argument, builds and return the suffix array for the given string
int *buildSuffixArray(char *txt, int n)
{
    // A structure to store suffixes and their indexes
    struct suffix suffixes[n];
 
    // Store suffixes and their indexes in an array of structures.
    // The structure is needed to sort the suffixes alphabetically
    // and maintain their old indexes while sorting
    for (int i = 0; i < n; i++)
    {
        suffixes[i].index = i;
        suffixes[i].suff = (txt+i);
    }
 
    // Sort the suffixes using the comparison function
    // defined above.
    sort(suffixes, suffixes+n, cmp);
 
    // Store indexes of all sorted suffixes in the suffix array
    int *suffixArr = new int[n];
    for (int i = 0; i < n; i++)
        suffixArr[i] = suffixes[i].index;
 
    // Return the suffix array
    return  suffixArr;
}
 
// A utility function to print an array of given size
void printArr(int arr[], int n)
{
    for(int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;
}
\end{lstlisting}

\subsection{LCP}

\begin{lstlisting}[style=compactcpp]
// Structure to store information of a suffix
struct suffix
{
    int index;  // To store original index
    int rank[2]; // To store ranks and next rank pair
};
 
// A comparison function used by sort() to compare two suffixes
// Compares two pairs, returns 1 if first pair is smaller
int cmp(struct suffix a, struct suffix b)
{
    return (a.rank[0] == b.rank[0])? (a.rank[1] < b.rank[1] ?1: 0):
           (a.rank[0] < b.rank[0] ?1: 0);
}
 
// This is the main function that takes a string 'txt' of size n as an
// argument, builds and return the suffix array for the given string
vector<int> buildSuffixArray(string txt, int n)
{
    // A structure to store suffixes and their indexes
    struct suffix suffixes[n];
 
    // Store suffixes and their indexes in an array of structures.
    // The structure is needed to sort the suffixes alphabetically
    // and maintain their old indexes while sorting
    for (int i = 0; i < n; i++)
    {
        suffixes[i].index = i;
        suffixes[i].rank[0] = txt[i] - 'a';
        suffixes[i].rank[1] = ((i+1) < n)? (txt[i + 1] - 'a'): -1;
    }
 
    // Sort the suffixes using the comparison function
    // defined above.
    sort(suffixes, suffixes+n, cmp);
 
    // At his point, all suffixes are sorted according to first
    // 2 characters.  Let us sort suffixes according to first 4
    // characters, then first 8 and so on
    int ind[n];  // This array is needed to get the index in suffixes[]
    // from original index.  This mapping is needed to get
    // next suffix.
    for (int k = 4; k < 2*n; k = k*2)
    {
        // Assigning rank and index values to first suffix
        int rank = 0;
        int prev_rank = suffixes[0].rank[0];
        suffixes[0].rank[0] = rank;
        ind[suffixes[0].index] = 0;
 
        // Assigning rank to suffixes
        for (int i = 1; i < n; i++)
        {
            // If first rank and next ranks are same as that of previous
            // suffix in array, assign the same new rank to this suffix
            if (suffixes[i].rank[0] == prev_rank &&
                    suffixes[i].rank[1] == suffixes[i-1].rank[1])
            {
                prev_rank = suffixes[i].rank[0];
                suffixes[i].rank[0] = rank;
            }
            else // Otherwise increment rank and assign
            {
                prev_rank = suffixes[i].rank[0];
                suffixes[i].rank[0] = ++rank;
            }
            ind[suffixes[i].index] = i;
        }
 
        // Assign next rank to every suffix
        for (int i = 0; i < n; i++)
        {
            int nextindex = suffixes[i].index + k/2;
            suffixes[i].rank[1] = (nextindex < n)?
                                  suffixes[ind[nextindex]].rank[0]: -1;
        }
 
        // Sort the suffixes according to first k characters
        sort(suffixes, suffixes+n, cmp);
    }
 
    // Store indexes of all sorted suffixes in the suffix array
    vector<int>suffixArr;
    for (int i = 0; i < n; i++)
        suffixArr.push_back(suffixes[i].index);
 
    // Return the suffix array
    return  suffixArr;
}
 
/* To construct and return LCP */
vector<int> kasai(string txt, vector<int> suffixArr)
{
    int n = suffixArr.size();
 
    // To store LCP array
    vector<int> lcp(n, 0);
 
    // An auxiliary array to store inverse of suffix array
    // elements. For example if suffixArr[0] is 5, the
    // invSuff[5] would store 0.  This is used to get next
    // suffix string from suffix array.
    vector<int> invSuff(n, 0);
 
    // Fill values in invSuff[]
    for (int i=0; i < n; i++)
        invSuff[suffixArr[i]] = i;
 
    // Initialize length of previous LCP
    int k = 0;
 
    // Process all suffixes one by one starting from
    // first suffix in txt[]
    for (int i=0; i<n; i++)
    {
        /* If the current suffix is at n-1, then we dont
           have next substring to consider. So lcp is not
           defined for this substring, we put zero. */
        if (invSuff[i] == n-1)
        {
            k = 0;
            continue;
        }
 
        /* j contains index of the next substring to
           be considered  to compare with the present
           substring, i.e., next string in suffix array */
        int j = suffixArr[invSuff[i]+1];
 
        // Directly start matching from k'th index as
        // at-least k-1 characters will match
        while (i+k<n && j+k<n && txt[i+k]==txt[j+k])
            k++;
 
        lcp[invSuff[i]] = k; // lcp for the present suffix.
 
        // Deleting the starting character from the string.
        if (k>0)
            k--;
    }
 
    // return the constructed lcp array
    return lcp;
}
 
// Utility function to print an array
void printArr(vector<int>arr, int n)
{
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;
}
\end{lstlisting}

\subsection{Z Function}

\begin{lstlisting}[style=compactcpp]
vector<int> z_function(string s) {
    int n = s.size();
    vector<int> z(n);
    int l = 0, r = 0;
    for(int i = 1; i < n; i++) {
        if(i < r) {
            z[i] = min(r - i, z[i - l]);
        }
        while(i + z[i] < n && s[z[i]] == s[i + z[i]]) {
            z[i]++;
        }
        if(i + z[i] > r) {
            l = i;
            r = i + z[i];
        }
    }
    return z;
}
\end{lstlisting}

\subsection{Longest Palindrome}

\begin{lstlisting}[style=compactcpp]
typedef long long ll;
typedef vector<int> vec;
const ll mod=1e9+7;
const int MAX=1e6+3;
vector<int> lps(2*MAX);
int n;
string s;

//ascii https://elcodigoascii.com.ar/

void show(int idx)
{
    int start=(idx-lps[idx])/2;
    int end=start+lps[idx];
    for(int i=start;i<end;i++){
        cout<<s[i];
    }
    
}

inline void solve()
{
    cin>>s;
    n=s.size();
    lps[0]=0;
    lps[1]=1;
    int rightCenter,leftCenter,center,curRightCenter,curLeftCenter;
    center=1;
    rightCenter=center+lps[center];
    leftCenter=center-lps[center];
    int maxLPScenter=1;
    int diff=-1;
    bool exp;
    for(curRightCenter=2;curRightCenter<2*n+1;curRightCenter++)
    {
        //Condicion de cambio de centro
        curLeftCenter=2*center-curRightCenter;
        diff=rightCenter-curRightCenter;
        exp=false;
        if(diff>=0){
            if(lps[curLeftCenter]<diff){
                lps[curRightCenter]=lps[curLeftCenter];
            }
            else if(lps[curLeftCenter]==diff && rightCenter==2*n)
            {
                lps[curRightCenter]=lps[curLeftCenter];
            }
            else if(lps[curLeftCenter]==diff && rightCenter<2*n){
                lps[curRightCenter]=lps[curLeftCenter];
                exp=true;
            }
            else if(lps[curLeftCenter]>diff){
                lps[curRightCenter]=diff;
                exp=true;
            }
        }
        else{
            lps[curRightCenter]=0;
            exp=true;
        }
        if(exp)
        {
            while(((curRightCenter+lps[curRightCenter])<2*n && curRightCenter-lps[curRightCenter]>0) 
            && ((curRightCenter+lps[curRightCenter]+1)%2==0 || s[(curRightCenter+lps[curRightCenter]+1)/2]==s[(curRightCenter-lps[curRightCenter]-1)/2])){
                lps[curRightCenter]++;
            }
        }
        if(lps[curRightCenter]>lps[maxLPScenter])
        {
            maxLPScenter=curRightCenter;
        }
        if(curRightCenter+lps[curRightCenter]>rightCenter){
            center=curRightCenter;
            rightCenter=curRightCenter+lps[curRightCenter];
        }
    }
    show(maxLPScenter);

}

\end{lstlisting}

\subsection{String Hashing}

\begin{lstlisting}[style=compactcpp]
typedef long long ll;
typedef vector<int> vec;
const ll mod=1e9+7;
const int MAX=1e6+3;
const ll A=911382323;
const ll B=972663749;
ll str[MAX];
ll pk[MAX];
bool prefix[MAX]={false};



ll subs(int i,int j)
{
    if(i)
        return ((str[j]-pk[j-i+1]*str[i-1])%B+B)%B;
    else
        return str[j];
}

//ascii https://elcodigoascii.com.ar/

inline void solve()
{
    string s; cin>>s;
    memset(prefix,true,sizeof(prefix));
    str[0]=s[0];
    pk[0]=1;
    int n=s.size();
    for(int i=1;i<n;i++)
    {
        str[i]=A*str[i-1]+s[i];
        pk[i]=pk[i-1]*A;
        pk[i]%=B;
        str[i]%=B;
    }
    ll aux;
    bool ver;
    for(int i=1;i<=n;i++)
    {
        aux=subs(0,i-1);
        for(int j=0;j+i<=n;j+=i)
        {
            if(aux!=subs(j,j+i-1))
            {
                //cout<<aux<<" "<<subs(j,j+i-1)<<" "<<i<<" "<<j<<endl;
                prefix[i]=false;
                break;
            }
        }
        if(!prefix[i]) continue;
        if(n%i && (subs(n-n%i,n-1)!=subs(0,n%i-1)))
        {
            continue;
        }
        cout<<i<<" ";
    }
}
\end{lstlisting}

\subsection{Manacher Algorithm}

\begin{lstlisting}[style=compactcpp]
vector<int> manacher(string s) {
    string t;
    for(auto c: s) {
        t += string("#") + c;
    }
    auto res = manacher_odd(t + "#");
    return vector<int>(begin(res) + 1, end(res) - 1);
}
\end{lstlisting}

\subsection{Suffix Automaton}

\begin{lstlisting}[style=compactcpp]
struct state {
    int len, link;
    map<char, int> next;
};

const int MAXLEN = 100000;
state st[MAXLEN * 2];
int sz, last;

void sa_init() {
    st[0].len = 0;
    st[0].link = -1;
    sz++;
    last = 0;
}

void sa_extend(char c) {
    int cur = sz++;
    st[cur].len = st[last].len + 1;
    int p = last;
    while (p != -1 && !st[p].next.count(c)) {
        st[p].next[c] = cur;
        p = st[p].link;
    }
    if (p == -1) {
        st[cur].link = 0;
    } else {
        int q = st[p].next[c];
        if (st[p].len + 1 == st[q].len) {
            st[cur].link = q;
        } else {
            int clone = sz++;
            st[clone].len = st[p].len + 1;
            st[clone].next = st[q].next;
            st[clone].link = st[q].link;
            while (p != -1 && st[p].next[c] == q) {
                st[p].next[c] = clone;
                p = st[p].link;
            }
            st[q].link = st[cur].link = clone;
        }
    }
    last = cur;
}

long long get_diff_strings(){
    long long tot = 0;
    for(int i = 1; i < sz; i++) {
        tot += st[i].len - st[st[i].link].len;
    }
    return tot;
}

long long get_tot_len_diff_substings() {
    long long tot = 0;
    for(int i = 1; i < sz; i++) {
        long long shortest = st[st[i].link].len + 1;
        long long longest = st[i].len;

        long long num_strings = longest - shortest + 1;
        long long cur = num_strings * (longest + shortest) / 2;
        tot += cur;
    }
    return tot;
}

string lcs (string S, string T) {
    sa_init();
    for (int i = 0; i < S.size(); i++)
        sa_extend(S[i]);

    int v = 0, l = 0, best = 0, bestpos = 0;
    for (int i = 0; i < T.size(); i++) {
        while (v && !st[v].next.count(T[i])) {
            v = st[v].link ;
            l = st[v].len;
        }
        if (st[v].next.count(T[i])) {
            v = st [v].next[T[i]];
            l++;
        }
        if (l > best) {
            best = l;
            bestpos = i;
        }
    }
    return T.substr(bestpos - best + 1, best);
} 
\end{lstlisting}
\section{Formulas}

\subsection{Sums}

\[
c^a+c^{a+1}+\dots + c^b = \frac{c^{b+1}-c^a}{c-1}, c\neq 1
\]

\textbf{Gauss}

\[
1+2+3+...+n = \frac{n(n+1)}{2}
\]

\textbf{Gauss squares}

\[
1^2+2^2+3^2+...+n^2 = \frac{n(2n+1)(n+1)}{6}
\]

\textbf{Cubes}

\[
1^3+2^3+3^3+...+n^3 = \frac{n^2(n+1)^2}{4}
\]

\textbf{Powers of 4}

\[
1^4+2^4+3^4+...+n^4 = \frac{n(2n+1)(n+1)(3n^2+3n-1)}{30}
\]

\subsection{Catalan numbers}
\[
C_0 = 1, \quad C_{n+1} = \sum_{i=0}^{n} C_i C_{n-i} \quad \text{(Recursive)}
\]
\[
C_n = \frac{1}{n+1} \binom{2n}{n} = \binom{2n}{n} - \binom{2n}{n+1} = \frac{(2n)!}{(n+1)!n!} \quad \text{(Closed-form)}
\]

\begin{itemize}
    \item \textbf{Valid Parentheses}: Count of balanced parentheses expressions with \( n \) pairs.
    \item \textbf{Full Binary Trees}: Structurally unique full binary trees with \( n+1 \) leaves.
    \item \textbf{Polygon Triangulation}: Ways to triangulate a convex \( (n+2) \)-gon.
    \item \textbf{Dyck Paths}: Paths from \( (0,0) \) to \( (2n,0) \) that never dip below the x-axis.
    \item \textbf{Non-Crossing Partitions}: Ways to connect \( 2n \) points on a circle without crossing chords.
    \item \textbf{Stack Permutations}: Valid stack-sortable permutations of length \( n \).
    \item \textbf{Mountain Ranges}: Sequences of \( 2n \) up/down steps forming valid mountain ranges.
    \item \textbf{Unique BSTs}: Number of distinct binary search trees with \( n \) keys.
    \item \textbf{Diagonal-Avoiding Paths}: Paths in a grid from \( (0,0) \) to \( (n,n) \) without crossing the diagonal.
\end{itemize}

\subsection{Cayley's Formula}

Number of labeled trees of n vertices: $n^{n-2}$.

Number of rooted forest of n vertices is: $(n+1)^{n-1}$

\subsection{Geometric series}

% Finite Geometric Series
\textbf{Finite:} \[\quad \sum_{k=0}^{n} ar^k = 
\begin{cases} 
a \dfrac{1 - r^{n+1}}{1 - r} & \text{if } r \neq 1, \\
a(n + 1) & \text{if } r = 1.
\end{cases}
\]
% Infinite Geometric Series
\textbf{Infinite:} \[\quad \sum_{k=0}^{\infty} ar^k = \frac{a}{1 - r} \quad \text{(converges iff } |r| < 1\text{)}
\]
\subsection{Divisors}

The number of divisors of any number n is:

\[
\begin{cases}
    \approx 100 \quad n< 5 \times 10^4 \\
    \approx 500 \quad n<1 \times 10^7 \\
    \approx 2000 \quad n < 1 \times 10^10 \\
    \approx 200000 \quad n < 1 \times 10^19
\end{cases}
\]

\subsection{Number of primes between 1 and n}

\[
\frac{n}{ln(n)}
\]


\subsection{Pythagorean triplets}

\[
a = k \cdot (m^2 - n^2), \quad b = k\cdot(2mn), \quad c = k\cdot(m^2+n^2)
\]

With $m>n>0$, $k=0$, $m\perp n$, and either m or n even.


\subsection{Derangments}

Permutations of a set sush that none of the elements appear in their original position.

\[
D(n) = (n-1)(D(n-1)+D(n-2)) = nD(n-1)+(-1)^n = \lfloor \frac{n!}{e}\rfloor
\]

\section{Miscellaneous}

Gus, this is a reminder to add more stuff here

\subsection{Random number generator}

\begin{lstlisting}[style=compactcpp]
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

uniform_int_distribution<int>(0,n)
normal_distribution<> normal_dist(mean,2)
exponential_distribution
\end{lstlisting}

\subsection{Custom comparators}

\begin{lstlisting}[style=compactcpp]
bool cmp(const Edge &x, const Edge &y) {return x.w < y.w}
\end{lstlisting}

\subsection{Kadane's Algorithm}
\begin{lstlisting}[style=compactcpp]
inline void solve()
{
    int n; cin>>n;
    vector<int> normal(n);
    vector<int> rever(n);
    FO(i,n){
        cin>>normal[i];
        rever[i]=-normal[i];
    }
    ll sum = 0, max_sum = -1e9;
    ll sumr=0;
    for (int i = 0; i < n; i++) {
        sum += normal[i];
        max_sum = max(max_sum, sum);
        sumr+= rever[i];
        max_sum=max(max_sum,sumr);
        if(i%2==1){
            sum=max(sum,sumr);
            sumr=max(sum,sumr);
        }
        if (sum < 0) sum = 0;
        if (sumr<0) sumr=0;
    }
    cout<<max_sum<<endl;
    //Geeks for geeks
    //https://www.geeksforgeeks.org/cses-solutions-maximum-subarray-sum/
}
\end{lstlisting}

\begin{lstlisting}[style=compactcpp]
ll kadane(vector<int> &a, int n){
    ll arns = a[0], zum = 0;

    for (int i = 0; i < n; i++){
        zum += a[i];
        arns = max(arns, zum);
        zum = max(zum, 0LL);
    }

    return arns;
}
\end{lstlisting}

\subsection{Moore's Voting Algorithm}

\begin{lstlisting}[style=compactcpp]
int majorityElement(vector<int>& nums) {
    int vote = 0, r = 0;
    for(int i=0; i<nums.size();i++){
        if(nums[i] == nums[r])
            vote++;
        else
            vote--;
        if(vote == 0){
            r = i;
            vote = 1;
        } 
    }

    int cnt = 0;
    int goal = (nums.size())/2;
    for(int i=0; i<nums.size(); i++){
        if(nums[i] == nums[r]){
            cnt++;
            if(cnt > goal){
                break;
            }
        }
    }

    return nums[r];
}
\end{lstlisting}

\subsection{Sliding Window Minimum}

\begin{lstlisting}[style=compactcpp]
// Sliding window minimum using monotonic deque
// Maintains minimum element in each window of size k efficiently in O(n)
// Uses deque to store indices of potential minimum elements in increasing order
inline void solve()
{
    int n,k; cin>>n>>k;
    ll x,a,b,c; cin>>x>>a>>b>>c;
    
    ll lf=x,rt=x;
    ll res=0;
    deque<pair<int,int>> q;
    q.push_back({x,0});
    FO(i,k-1){
        rt=(a*rt+b)%c;
        while(!q.empty() && rt<q.back().X){
           q.pop_back();
        }
        q.push_back({rt,i+1});
    }
    int t=n-k+1;
    int idx_left=0;
    int idx_right=k-1;
    while(t--)
    {
        res^=q.front().X;
        if(q.front().Y==idx_left){
            q.pop_front();
        }
        lf=(a*lf+b)%c;
        idx_left++;
        rt=(a*rt+b)%c;
        idx_right++;
        while(!q.empty() && rt<q.back().X){
           q.pop_back();
        }
        q.push_back({rt,idx_right});
        
    }
    cout<<res<<endl;
}
\end{lstlisting}

\subsection{Sliding Window OR}

\begin{lstlisting}[style=compactcpp]
// Sliding window OR using prefix and suffix arrays
// Computes bitwise OR for all windows of size k efficientlAdd the following code.
1. Search for a corresponding section
2. Add or update the code accordingly
3. Add a small comment at the start to show what it does:

y in O(n)
// Uses prefix OR from block starts and suffix OR to block ends
inline void solve()
{
    int n,k; cin>>n>>k;
    ll x,a,b,c; cin>>x>>a>>b>>c;
    arr[1]=x;
    prefix[1]=x;
    for(int i=2;i<=n;i++)
    {
        arr[i]=(a*arr[i-1]+b)%c;
        if(i%k==1)
        {
            prefix[i]=arr[i];
        }
        else{
            prefix[i]=arr[i]|prefix[i-1];
        }
    }
    suffix[n]=arr[n];
    for(int i=n-1;i;i--){
        if(i%k==0)
        {
            suffix[i]=arr[i];
        }
        else{
            suffix[i]=arr[i]|suffix[i+1];
        }
    }
    int lf=1,rt=k;
    ll res=0;
    if(k==1){
        FO(i,n-k+1){
            res^=arr[i+1];
        }
    }
    else{
        FO(i,n-k+1)
        {
            res^=suffix[lf]|prefix[rt];
            lf++; rt++;
        }
    }
   
    cout<<res<<endl;
}
\end{lstlisting}

\section{Marranadas de C++}

\subsection{Compilation}

\texttt{g++-13 -std=c++20 name.cpp}

\subsection{Compiler optimizations}


\begin{lstlisting}[style=compactcpp]
// Makes bit operations faster
#pragma GCC target("popcnt") 

//Auto vectorize for-loops and optimizes floating points (assumes associativity and turns off denormals)
#pragma GCC optimize("Ofast")

// Doubles performance of vectorized code, crashes in old computers
#pragma GCC target("avx2")

#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2,bmi,bmi2,lzcnt,popcnt")
\end{lstlisting}

\subsection{Decimal printing}

Friendly reminder to use \texttt{printf()} with decimals

\begin{lstlisting}[style=compactcpp]
cout<< fixed << setprecision(n)<<endl;
\end{lstlisting}

\subsection{Bit tricks}

x \& -x is the least bit in x

c = x \& -x, r=x+c, \texttt{(((bin\_pow(r,x)) >> 2)/c) OR r}  next number bigger than x same number of bits set.

\end{multicols*}


\end{document}